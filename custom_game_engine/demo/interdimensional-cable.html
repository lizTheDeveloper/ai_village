<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üì∫ Interdimensional Cable</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', monospace;
      background: #000;
      color: #0f0;
      padding: 2rem;
      min-height: 100vh;
      background-image:
        repeating-linear-gradient(0deg, rgba(0, 255, 0, 0.05) 0px, transparent 2px),
        repeating-linear-gradient(90deg, rgba(0, 255, 0, 0.05) 0px, transparent 2px);
      background-size: 4px 4px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 2rem;
      padding: 1rem;
      border: 2px solid #0f0;
      background: rgba(0, 255, 0, 0.1);
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
    }

    h1 {
      font-size: 3rem;
      text-shadow: 0 0 10px #0f0, 0 0 20px #0f0;
      animation: flicker 3s infinite alternate;
    }

    @keyframes flicker {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.8; }
    }

    .subtitle {
      color: #0a0;
      font-size: 1rem;
      margin-top: 0.5rem;
    }

    .tv-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 2rem;
      margin-bottom: 2rem;
    }

    .tv-show {
      border: 3px solid #0f0;
      background: #001100;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.3s;
      position: relative;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
    }

    .tv-show:hover {
      box-shadow: 0 0 30px rgba(0, 255, 0, 0.6);
      transform: scale(1.05);
    }

    .tv-show.playing {
      border-color: #ff0;
      box-shadow: 0 0 30px rgba(255, 255, 0, 0.8);
    }

    .show-title {
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
      text-align: center;
      color: #0ff;
    }

    .show-status {
      font-size: 0.8rem;
      color: #0a0;
      text-align: center;
      margin-bottom: 0.5rem;
    }

    .canvas-container {
      width: 100%;
      height: 300px;
      background: #000;
      border: 2px solid #030;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }

    .canvas-container canvas {
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }

    .loading {
      color: #0a0;
      font-size: 0.9rem;
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }

    .player-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .player-container.active {
      display: flex;
    }

    .player {
      background: #000;
      border: 4px solid #0f0;
      padding: 2rem;
      max-width: 90vw;
      max-height: 90vh;
      box-shadow: 0 0 50px rgba(0, 255, 0, 0.8);
    }

    .player-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      padding-bottom: 1rem;
      border-bottom: 2px solid #0f0;
    }

    .player-title {
      font-size: 1.5rem;
      color: #0ff;
    }

    .close-btn {
      background: #0f0;
      color: #000;
      border: none;
      padding: 0.5rem 1rem;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      font-weight: bold;
    }

    .close-btn:hover {
      background: #0ff;
    }

    .player-canvas {
      background: #000;
      border: 2px solid #030;
      margin-bottom: 1rem;
    }

    .player-controls {
      display: flex;
      gap: 1rem;
      align-items: center;
      justify-content: center;
    }

    .control-btn {
      background: #0a0;
      color: #000;
      border: 2px solid #0f0;
      padding: 0.5rem 1rem;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      font-weight: bold;
    }

    .control-btn:hover {
      background: #0f0;
    }

    .back-link {
      text-align: center;
      margin-top: 2rem;
      padding-top: 2rem;
      border-top: 2px solid #030;
    }

    .back-link a {
      color: #0f0;
      text-decoration: none;
    }

    .back-link a:hover {
      color: #0ff;
      text-decoration: underline;
    }

    .error {
      background: #300;
      color: #f00;
      padding: 1rem;
      margin-bottom: 1rem;
      border: 2px solid #f00;
      display: none;
    }

    .error.active {
      display: block;
    }

    .direction-selector {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-top: 0.5rem;
      justify-content: center;
    }

    .direction-btn {
      background: #003300;
      color: #0f0;
      border: 1px solid #0f0;
      padding: 0.25rem 0.5rem;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      font-size: 0.7rem;
    }

    .direction-btn:hover, .direction-btn.active {
      background: #0f0;
      color: #000;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üì∫ INTERDIMENSIONAL CABLE üì∫</h1>
      <p class="subtitle">Broadcasting from infinite realities since ‚àû</p>
    </header>

    <div class="error" id="error"></div>

    <div class="tv-grid" id="tvGrid">
      <!-- TV shows will be inserted here -->
    </div>

    <div class="back-link">
      <a href="/">&larr; Back to Reality (probably)</a>
    </div>
  </div>

  <!-- Fullscreen Player -->
  <div class="player-container" id="player">
    <div class="player">
      <div class="player-header">
        <div class="player-title" id="playerTitle">Loading...</div>
        <button class="close-btn" onclick="closePlayer()">CLOSE [X]</button>
      </div>
      <canvas id="playerCanvas" class="player-canvas" width="480" height="480"></canvas>
      <div class="player-controls">
        <button class="control-btn" onclick="togglePlayback()">‚èØ PAUSE</button>
        <span id="fpsCounter" style="color: #0a0;">FPS: --</span>
      </div>
      <div class="direction-selector" id="directionSelector"></div>
    </div>
  </div>

  <script>
    // Character data from PixelLab (hardcoded to avoid API auth issues)
    const USER_ID = '8e579d97-da21-4602-98b0-63163efd9ade';

    const SHOWS = [
      {
        id: 'villager',
        name: 'VILLAGER WALKING SHOW',
        animation: 'walking-8-frames',
        frameCount: 8,
        directions: ['south', 'south-west', 'west', 'north-west'],
        description: 'Villager walking in all directions',
        isLocal: true,
        type: 'sprite'
      },
      {
        id: 'villager',
        name: 'VILLAGER WALKING SHOWCASE',
        animation: 'walking-8-frames',
        frameCount: 8,
        directions: ['south', 'south-west', 'west', 'north-west'],
        description: 'Villager walking animation loop',
        isLocal: true,
        type: 'sprite'
      },
      {
        id: 'alien-invasion',
        name: 'ALIEN INVASION - BREAKING NEWS',
        description: 'Field reporter captures alien landing in village square',
        recordingPath: '/mock-recordings/alien-invasion.json',
        type: 'recording'
      },
      {
        id: 'gladiator-arena',
        name: 'ARENA BLOODSPORT - CHAMPIONSHIP FINALS',
        description: 'Two legendary gladiators clash in the final match of the season',
        recordingPath: '/mock-recordings/gladiator-arena.json',
        type: 'recording'
      },
      {
        id: 'reproductive-test',
        name: 'FERTILITY FESTIVAL - SCIENTIFIC DOCUMENTATION',
        description: 'Reproductive systems E2E test at the annual Spring Ritual',
        recordingPath: '/mock-recordings/reproductive-test.json',
        type: 'recording'
      },
      {
        id: 'market-festival',
        name: 'HARVEST MARKET - GRAND OPENING DAY',
        description: 'Bustling village market with merchants, performers, and shoppers',
        recordingPath: '/mock-recordings/market-festival.json',
        type: 'recording'
      },
      {
        id: 'magic-ritual',
        name: 'ARCANE DISASTER - RITUAL GONE WRONG',
        description: 'Apprentice mages attempt summoning ritual with catastrophic results',
        recordingPath: '/mock-recordings/magic-ritual.json',
        type: 'recording'
      },
      {
        id: 'disaster-response',
        name: 'BREAKING NEWS - EARTHQUAKE HITS VILLAGE',
        description: 'Emergency response teams coordinate rescue during catastrophic earthquake',
        recordingPath: '/mock-recordings/disaster-response.json',
        type: 'recording'
      },
      {
        id: 'gladiator-combat-real',
        name: 'PROCEDURAL GLADIATOR COMBAT - AI GENERATED',
        description: 'Procedurally generated gladiator combat with physics simulation',
        recordingPath: '/mock-recordings/gladiator-combat-real.json',
        type: 'recording'
      },
      {
        id: 'fae-vs-angels',
        name: 'FAE VS ANGELS - ETHEREAL DUEL',
        description: 'Transcendent fae battles celestial angel with PixelLab animations',
        recordingPath: '/mock-recordings/fae-vs-angels.json',
        assetsPath: '/combat-assets/fae-vs-angels/manifest.json',
        type: 'combat-replay'
      },
      {
        id: 'book-tentacle-vs-bambi',
        name: 'NECRONOMICON VS BAMBI - FORBIDDEN KNOWLEDGE',
        description: 'Eldritch tome-beast faces weaponized deer in dark library',
        recordingPath: '/mock-recordings/book-tentacle-vs-bambi.json',
        type: 'recording'
      },
    ];

    class SpriteAnimationPlayer {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.frames = [];
        this.currentFrame = 0;
        this.isPlaying = true;
        this.fps = 8;
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / this.fps;
      }

      async loadAnimation(show, direction = 'south') {
        try {
          // Check if direction is available
          if (!show.directions.includes(direction)) {
            throw new Error(`Direction ${direction} not available for this show`);
          }

          // Load frames
          this.frames = [];
          for (let i = 0; i < show.frameCount; i++) {
            const frameNum = String(i).padStart(3, '0');  // 000, 001, 002, etc.

            let frameUrl;
            if (show.isLocal) {
              // Load from local assets
              frameUrl = `/assets/sprites/pixellab/${show.id}/animations/${show.animation}/${direction}/frame_${frameNum}.png`;
            } else {
              // Load from Backblaze
              frameUrl = `https://backblaze.pixellab.ai/file/pixellab-characters/${USER_ID}/${show.id}/animations/${show.animation}/${direction}/frame_${frameNum}.png`;
            }

            const img = await this.loadImage(frameUrl);
            this.frames.push(img);
          }

          this.currentFrame = 0;
          return true;
        } catch (error) {
          console.error('Failed to load animation:', error);
          throw error;
        }
      }

      loadImage(url) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            console.log('Loaded frame:', url);
            resolve(img);
          };
          img.onerror = (e) => {
            console.error('Failed to load frame:', url, e);
            reject(new Error(`Failed to load: ${url}`));
          };
          img.src = url + '?t=' + Date.now();
          setTimeout(() => reject(new Error('Image load timeout: ' + url)), 10000);
        });
      }

      animate(timestamp) {
        if (!this.isPlaying || this.frames.length === 0) {
          requestAnimationFrame((t) => this.animate(t));
          return;
        }

        const elapsed = timestamp - this.lastFrameTime;
        if (elapsed > this.frameInterval) {
          this.lastFrameTime = timestamp;

          // Clear canvas
          this.ctx.fillStyle = '#000';
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          // Draw current frame (scaled up)
          const frame = this.frames[this.currentFrame];
          if (frame) {
            const scale = Math.min(this.canvas.width / frame.width, this.canvas.height / frame.height) * 0.8;
            const x = (this.canvas.width - frame.width * scale) / 2;
            const y = (this.canvas.height - frame.height * scale) / 2;

            this.ctx.imageSmoothingEnabled = false;
            this.ctx.drawImage(frame, x, y, frame.width * scale, frame.height * scale);
          }

          // Next frame
          this.currentFrame = (this.currentFrame + 1) % this.frames.length;
        }

        requestAnimationFrame((t) => this.animate(t));
      }

      start() {
        this.isPlaying = true;
        requestAnimationFrame((t) => this.animate(t));
      }

      pause() {
        this.isPlaying = false;
      }

      resume() {
        this.isPlaying = true;
      }
    }

    /**
     * ReplayRenderer - Renders VideoReplayComponent recordings
     *
     * Handles entity snapshot playback:
     * - Loads recording JSON with frame data
     * - Resolves entity types to sprite paths
     * - Renders entities at recorded positions
     * - Handles camera position and zoom
     * - Interpolates between frames for smooth playback
     */
    class ReplayRenderer {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.recording = null;
        this.frames = [];
        this.currentFrameIndex = 0;
        this.isPlaying = true;
        this.fps = 2; // Match VideoReplayComponent recording rate
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / this.fps;
        this.spriteCache = new Map(); // Cache loaded sprite frames
      }

      async loadRecording(recordingPathOrData) {
        try {
          console.log('[ReplayRenderer] Loading recording:', recordingPathOrData);

          // Check if this is embedded recording data or a path
          if (typeof recordingPathOrData === 'object' && recordingPathOrData.frames) {
            // Embedded recording data from game world
            this.recording = recordingPathOrData;
            console.log('[ReplayRenderer] Using embedded recording data from game world');
          } else {
            // Path to JSON file
            const response = await fetch(recordingPathOrData);
            if (!response.ok) throw new Error(`Failed to load recording: ${response.status}`);

            this.recording = await response.json();
          }

          this.frames = this.recording.frames;
          this.currentFrameIndex = 0;

          console.log(`[ReplayRenderer] Loaded ${this.frames.length} frames from "${this.recording.title}"`);

          // Preload sprite frames for all entities
          await this.preloadSprites();

          return true;
        } catch (error) {
          console.error('[ReplayRenderer] Failed to load recording:', error);
          throw error;
        }
      }

      async preloadSprites() {
        // Collect all unique entity types and animation states
        const entitySprites = new Map(); // entityType -> Set of animation states

        for (const frame of this.frames) {
          for (const entity of frame.entities) {
            if (!entitySprites.has(entity.entityType)) {
              entitySprites.set(entity.entityType, new Set());
            }
            entitySprites.get(entity.entityType).add(entity.animation.state);
          }
        }

        // Load sprites for each entity type + animation combo
        for (const [entityType, animationStates] of entitySprites) {
          for (const animState of animationStates) {
            await this.loadEntitySprite(entityType, animState);
          }
        }

        console.log(`[ReplayRenderer] Preloaded sprites for ${entitySprites.size} entity types`);
      }

      async loadEntitySprite(entityType, animationState) {
        const key = `${entityType}:${animationState}`;
        if (this.spriteCache.has(key)) return;

        try {
          // Map entity types to UNIQUE sprite configurations for variety
          const spriteMapping = {
            // Humanoids (animated) - each gets unique sprite
            'villager': { type: 'animated', id: 'villager', animation: 'walking-8-frames', frameCount: 8 },
            'gladiator': { type: 'static', id: 'odin' }, // Viking warrior
            'spectator': { type: 'static', id: 'human_male_brown' },
            'official': { type: 'static', id: 'human_male_blonde' },
            'merchant': { type: 'static', id: 'human_male_black_medium' },
            'bard': { type: 'static', id: 'pixie' }, // Magical performer
            'child': { type: 'static', id: 'rabbit_brown' }, // Smaller creature
            'guard': { type: 'static', id: 'human_male_black_dark' },
            'emergency': { type: 'static', id: 'human_male_black_light' },
            'scholar': { type: 'static', id: 'high-elf' },
            'mage': { type: 'static', id: 'forest-sprite' },

            // Aliens - different types
            'alien': { type: 'static', id: 'blob-alien' },

            // Animals - variety
            'dog': { type: 'static', id: 'dog_spotted' },
            'chicken': { type: 'static', id: 'chicken_brown' },
            'cow': { type: 'static', id: 'cow_brown' },
            'pig': { type: 'static', id: 'pig_pink' },
            'sheep': { type: 'static', id: 'sheep_white' },
            'horse': { type: 'static', id: 'horse_brown' },
            'cat': { type: 'static', id: 'cat_orange' },
            'rabbit': { type: 'static', id: 'rabbit_white' },
            'deer': { type: 'static', id: 'deer_brown' },
            'goat': { type: 'static', id: 'goat_white' },

            // Divine/special entities - unique gods
            'priest': { type: 'static', id: 'athena' },
            'priestess': { type: 'static', id: 'athena' },
            'deity_manifestation': { type: 'static', id: 'zeus' },
            'fertility_goddess': { type: 'static', id: 'hel' },
            'demon': { type: 'static', id: 'mantis-alien' },

            // Effects/particles
            'magic_effect': { type: 'static', id: 'pixie' },
            'particle_effect': { type: 'static', id: 'forest-sprite' },
            'fire_effect': { type: 'static', id: 'blob-alien' },

            // Buildings/objects
            'building': { type: 'static', id: 'tree' },
            'debris': { type: 'static', id: 'berry-bush' },
          };

          const spriteConfig = spriteMapping[entityType];
          if (!spriteConfig) {
            console.warn(`[ReplayRenderer] No sprite mapping for entity type: ${entityType}`);
            return;
          }

          const frames = [];

          if (spriteConfig.type === 'animated') {
            // Load animated sprite frames
            for (let i = 0; i < spriteConfig.frameCount; i++) {
              const frameNum = String(i).padStart(3, '0');
              const frameUrl = `/dist/assets/sprites/pixellab/${spriteConfig.id}/animations/${spriteConfig.animation}/south/frame_${frameNum}.png`;
              const img = await this.loadImage(frameUrl);
              frames.push(img);
            }
          } else {
            // Load static rotation sprite (just south facing)
            const frameUrl = `/dist/assets/sprites/pixellab/${spriteConfig.id}/rotations/south.png`;
            const img = await this.loadImage(frameUrl);
            frames.push(img);
          }

          this.spriteCache.set(key, frames);
          console.log(`[ReplayRenderer] Loaded ${frames.length} frames for ${key}`);
        } catch (error) {
          console.error(`[ReplayRenderer] Failed to load sprite for ${key}:`, error);
        }
      }

      loadImage(url) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => resolve(img);
          img.onerror = (e) => reject(new Error(`Failed to load: ${url}`));
          img.src = url;
          setTimeout(() => reject(new Error('Image load timeout: ' + url)), 10000);
        });
      }

      animate(timestamp) {
        if (!this.isPlaying || this.frames.length === 0) {
          requestAnimationFrame((t) => this.animate(t));
          return;
        }

        const elapsed = timestamp - this.lastFrameTime;
        if (elapsed > this.frameInterval) {
          this.lastFrameTime = timestamp;

          // Clear canvas
          this.ctx.fillStyle = '#000';
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          // Render current frame
          this.renderFrame(this.frames[this.currentFrameIndex]);

          // Next frame (loop)
          this.currentFrameIndex = (this.currentFrameIndex + 1) % this.frames.length;
        }

        requestAnimationFrame((t) => this.animate(t));
      }

      renderFrame(frame) {
        if (!frame || !frame.entities) return;

        // Calculate viewport transform
        const cameraX = frame.cameraX || 0;
        const cameraY = frame.cameraY || 0;
        const zoom = frame.cameraZoom || 1.0;

        // Sort entities by distance from camera (painter's algorithm)
        const sortedEntities = [...frame.entities].sort((a, b) =>
          (b.distanceFromCamera || 0) - (a.distanceFromCamera || 0)
        );

        // Render each entity
        for (const entity of sortedEntities) {
          this.renderEntity(entity, cameraX, cameraY, zoom);
        }

        // Draw recording info overlay
        this.ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
        this.ctx.font = '12px "Courier New"';
        this.ctx.fillText(`TICK ${frame.tick} | FRAME ${this.currentFrameIndex + 1}/${this.frames.length}`, 10, 20);
      }

      renderEntity(entity, cameraX, cameraY, zoom) {
        const key = `${entity.entityType}:${entity.animation.state}`;
        const spriteFrames = this.spriteCache.get(key);

        if (!spriteFrames || spriteFrames.length === 0) {
          // Draw placeholder circle if no sprite
          this.ctx.fillStyle = '#f00';
          const screenX = (entity.x - cameraX) * zoom + this.canvas.width / 2;
          const screenY = (entity.y - cameraY) * zoom + this.canvas.height / 2;
          this.ctx.beginPath();
          this.ctx.arc(screenX, screenY, 10 * zoom, 0, Math.PI * 2);
          this.ctx.fill();
          return;
        }

        // Get appropriate sprite frame
        const frameIndex = entity.animation.frame % spriteFrames.length;
        const sprite = spriteFrames[frameIndex];

        // Transform world coordinates to screen coordinates
        const screenX = (entity.x - cameraX) * zoom + this.canvas.width / 2;
        const screenY = (entity.y - cameraY) * zoom + this.canvas.height / 2;

        // NORMALIZE SIZE: Scale all sprites to consistent target height (64px base)
        const targetHeight = 64; // Base height in pixels
        const aspectRatio = sprite.width / sprite.height;
        const normalizedHeight = targetHeight * zoom;
        const normalizedWidth = normalizedHeight * aspectRatio;

        this.ctx.imageSmoothingEnabled = false;
        this.ctx.drawImage(
          sprite,
          screenX - normalizedWidth / 2,
          screenY - normalizedHeight / 2,
          normalizedWidth,
          normalizedHeight
        );
      }

      start() {
        this.isPlaying = true;
        requestAnimationFrame((t) => this.animate(t));
      }

      pause() {
        this.isPlaying = false;
      }

      resume() {
        this.isPlaying = true;
      }
    }

    /**
     * CombatReplayRenderer - Renders combat replays with PixelLab-generated sprites
     *
     * Loads manifest.json to map combat actions to animations,
     * renders PixelLab character sprites and animations with tiled background.
     */
    class CombatReplayRenderer {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.manifest = null;
        this.recording = null;
        this.frames = [];
        this.combatLog = [];
        this.currentFrameIndex = 0;
        this.isPlaying = true;
        this.fps = 4; // Playback speed
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / this.fps;

        // Sprite caches
        this.rotationCache = new Map();    // characterId:direction -> Image
        this.animationCache = new Map();   // characterId:animationName:direction -> Image[]
        this.backgroundTile = null;

        // Active animations (character playing an attack animation)
        this.activeAnimations = new Map(); // characterId -> { animation, direction, frameIndex, startTick }
      }

      async loadCombatReplay(show) {
        try {
          console.log('[CombatReplayRenderer] Loading combat replay:', show.id);

          // Load manifest
          const manifestResponse = await fetch(show.assetsPath);
          if (!manifestResponse.ok) throw new Error(`Failed to load manifest: ${manifestResponse.status}`);
          this.manifest = await manifestResponse.json();

          // Load recording
          const recordingResponse = await fetch(show.recordingPath);
          if (!recordingResponse.ok) throw new Error(`Failed to load recording: ${recordingResponse.status}`);
          this.recording = await recordingResponse.json();

          this.frames = this.recording.frames || [];
          this.combatLog = this.recording.combatLog || [];
          this.currentFrameIndex = 0;

          console.log(`[CombatReplayRenderer] Loaded ${this.frames.length} frames, ${this.combatLog.length} combat events`);

          // Preload all assets
          await this.preloadAssets();

          return true;
        } catch (error) {
          console.error('[CombatReplayRenderer] Failed to load:', error);
          throw error;
        }
      }

      async preloadAssets() {
        const basePath = this.manifest.combatId ? `/combat-assets/${this.manifest.combatId}/` : '';

        // Load background tile
        if (this.manifest.background?.path) {
          try {
            this.backgroundTile = await this.loadImage(basePath + this.manifest.background.path);
            console.log('[CombatReplayRenderer] Loaded background tile');
          } catch (e) {
            console.warn('[CombatReplayRenderer] Failed to load background:', e);
          }
        }

        // Load character rotations and animations
        for (const [charId, charData] of Object.entries(this.manifest.characters || {})) {
          // Load rotations
          if (charData.rotations) {
            for (const [dir, path] of Object.entries(charData.rotations)) {
              try {
                const img = await this.loadImage(basePath + path);
                this.rotationCache.set(`${charId}:${dir}`, img);
              } catch (e) {
                console.warn(`[CombatReplayRenderer] Failed to load rotation ${charId}:${dir}`);
              }
            }
          }

          // Load animations
          if (charData.animations) {
            for (const [animName, animData] of Object.entries(charData.animations)) {
              for (const dir of animData.directions || []) {
                const frames = [];
                for (let i = 0; i < animData.frames; i++) {
                  try {
                    const framePath = animData.path
                      .replace('{direction}', dir)
                      .replace('{frame}', String(i).padStart(3, '0'));
                    const img = await this.loadImage(basePath + framePath);
                    frames.push(img);
                  } catch (e) {
                    // Some frames may be missing
                  }
                }
                if (frames.length > 0) {
                  this.animationCache.set(`${charId}:${animName}:${dir}`, frames);
                }
              }
            }
          }
        }

        console.log(`[CombatReplayRenderer] Loaded ${this.rotationCache.size} rotations, ${this.animationCache.size} animations`);
      }

      loadImage(url) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => resolve(img);
          img.onerror = () => reject(new Error(`Failed to load: ${url}`));
          img.src = url;
          setTimeout(() => reject(new Error('Timeout: ' + url)), 10000);
        });
      }

      // Map entity type to character ID in manifest
      getCharacterId(entityType) {
        for (const [charId, charData] of Object.entries(this.manifest.characters || {})) {
          if (charData.type === entityType) return charId;
        }
        return null;
      }

      // Map facing angle to direction string
      angleToDirection(angle) {
        // Normalize angle to 0-360
        let normalized = ((angle % 360) + 360) % 360;
        // Map to 8 directions
        const directions = ['east', 'north-east', 'north', 'north-west', 'west', 'south-west', 'south', 'south-east'];
        const index = Math.round(normalized / 45) % 8;
        return directions[index];
      }

      // Check combat log for actions at this tick and trigger animations
      // Uses range checking since frame ticks (0,5,10...) don't align with combat ticks (19,39,59...)
      checkCombatActions(currentTick, previousTick) {
        for (const event of this.combatLog) {
          // Check if event falls within (previousTick, currentTick] range
          // Or exact match if previousTick not provided
          const inRange = previousTick !== undefined
            ? (event.tick > previousTick && event.tick <= currentTick)
            : (event.tick === currentTick);

          if (inRange && event.renderableOperation) {
            const op = event.renderableOperation;
            const charId = this.getCharacterId(op.actorType);
            if (!charId) {
              console.log(`[CombatReplayRenderer] No character found for actorType: ${op.actorType}`);
              continue;
            }

            // Map action to animation
            const animationName = this.manifest.actionMapping?.[op.action];
            if (!animationName) {
              console.log(`[CombatReplayRenderer] No animation mapping for action: ${op.action}`);
              continue;
            }

            // Check if animation exists in cache
            const charData = this.manifest.characters?.[charId];
            if (!charData?.animations?.[animationName]) {
              console.log(`[CombatReplayRenderer] Animation '${animationName}' not found in manifest for ${charId}`);
              continue;
            }

            // Start the animation
            this.activeAnimations.set(charId, {
              animation: animationName,
              frameIndex: 0,
              startTick: currentTick,
              duration: 6 // Frames to play
            });

            console.log(`[CombatReplayRenderer] Started animation: ${charId} -> ${animationName} (tick ${event.tick})`);
          }
        }
      }

      animate(timestamp) {
        if (!this.isPlaying || this.frames.length === 0) {
          requestAnimationFrame((t) => this.animate(t));
          return;
        }

        const elapsed = timestamp - this.lastFrameTime;
        if (elapsed > this.frameInterval) {
          this.lastFrameTime = timestamp;

          // Get current and previous frame for tick range checking
          const frame = this.frames[this.currentFrameIndex];
          const prevFrameIndex = this.currentFrameIndex > 0
            ? this.currentFrameIndex - 1
            : this.frames.length - 1;
          const prevFrame = this.frames[prevFrameIndex];

          // Handle loop wrap-around: if we just looped, previousTick should be -1
          const previousTick = this.currentFrameIndex === 0 ? -1 : prevFrame.tick;

          // Check for combat actions in the tick range (previousTick, currentTick]
          this.checkCombatActions(frame.tick, previousTick);

          // Clear and render
          this.ctx.fillStyle = this.manifest.background?.fallbackColor || '#000';
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          // Render background
          this.renderBackground();

          // Render frame
          this.renderFrame(frame);

          // Advance active animations
          for (const [charId, anim] of this.activeAnimations.entries()) {
            anim.frameIndex++;
            if (anim.frameIndex >= anim.duration) {
              this.activeAnimations.delete(charId);
            }
          }

          // Next frame (loop)
          this.currentFrameIndex = (this.currentFrameIndex + 1) % this.frames.length;
        }

        requestAnimationFrame((t) => this.animate(t));
      }

      renderBackground() {
        // Use radial gradient for ethereal combat arena instead of tiled isometric pattern
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        const radius = Math.max(this.canvas.width, this.canvas.height) * 0.7;

        const gradient = this.ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
        gradient.addColorStop(0, '#2a1040');    // Dark purple center
        gradient.addColorStop(0.4, '#1a0533');  // Deeper purple
        gradient.addColorStop(0.7, '#0d0219');  // Near black
        gradient.addColorStop(1, '#050108');    // Black edge

        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Add subtle grid pattern for arena floor effect
        this.ctx.strokeStyle = 'rgba(138, 43, 226, 0.15)'; // Faint purple
        this.ctx.lineWidth = 1;
        const gridSize = 32;

        for (let x = 0; x <= this.canvas.width; x += gridSize) {
          this.ctx.beginPath();
          this.ctx.moveTo(x, 0);
          this.ctx.lineTo(x, this.canvas.height);
          this.ctx.stroke();
        }
        for (let y = 0; y <= this.canvas.height; y += gridSize) {
          this.ctx.beginPath();
          this.ctx.moveTo(0, y);
          this.ctx.lineTo(this.canvas.width, y);
          this.ctx.stroke();
        }
      }

      renderFrame(frame) {
        if (!frame || !frame.entities) return;

        const cameraX = frame.cameraX || 0;
        const cameraY = frame.cameraY || 0;
        const zoom = frame.cameraZoom || 1.0;

        // Sort by distance
        const sorted = [...frame.entities].sort((a, b) =>
          (b.distanceFromCamera || 0) - (a.distanceFromCamera || 0)
        );

        for (const entity of sorted) {
          this.renderEntity(entity, cameraX, cameraY, zoom);
        }

        // Draw overlay
        this.ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
        this.ctx.font = '12px "Courier New"';
        this.ctx.fillText(`TICK ${frame.tick} | ${this.currentFrameIndex + 1}/${this.frames.length}`, 10, 20);

        // Show last combat action
        const recentAction = this.combatLog.find(e => e.tick <= frame.tick && e.tick > frame.tick - 20);
        if (recentAction) {
          this.ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';
          this.ctx.fillText(`${recentAction.attacker} ${recentAction.action} ${recentAction.defender}`, 10, 36);
        }
      }

      renderEntity(entity, cameraX, cameraY, zoom) {
        const charId = this.getCharacterId(entity.entityType);
        if (!charId) {
          // Fallback: draw colored circle
          this.renderPlaceholder(entity, cameraX, cameraY, zoom);
          return;
        }

        const direction = this.angleToDirection(entity.facingAngle || 0);
        const activeAnim = this.activeAnimations.get(charId);

        let sprite = null;
        let usingAnimation = false;

        if (activeAnim) {
          // Playing attack animation
          const key = `${charId}:${activeAnim.animation}:${direction}`;
          const frames = this.animationCache.get(key);
          if (frames && frames.length > 0) {
            sprite = frames[activeAnim.frameIndex % frames.length];
            usingAnimation = true;
            console.log(`[RENDER] ${charId} ANIMATION frame ${activeAnim.frameIndex}/${frames.length} of ${activeAnim.animation} (${direction})`);
          } else {
            console.warn(`[RENDER] ${charId} animation cache miss for key: ${key}`);
            console.warn(`[RENDER] Available keys:`, Array.from(this.animationCache.keys()).filter(k => k.startsWith(charId)));
          }
        }

        if (!sprite) {
          // Use rotation sprite
          sprite = this.rotationCache.get(`${charId}:${direction}`);
          // Fallback to south
          if (!sprite) sprite = this.rotationCache.get(`${charId}:south`);
        }

        if (!sprite) {
          this.renderPlaceholder(entity, cameraX, cameraY, zoom);
          return;
        }

        // Calculate screen position
        const screenX = (entity.x - cameraX) * zoom + this.canvas.width / 2;
        const screenY = (entity.y - cameraY) * zoom + this.canvas.height / 2;

        // Scale sprite (48px base, scale up for visibility)
        const scale = 3 * zoom;
        const w = sprite.width * scale;
        const h = sprite.height * scale;

        this.ctx.imageSmoothingEnabled = false;
        this.ctx.drawImage(sprite, screenX - w / 2, screenY - h / 2, w, h);
      }

      renderPlaceholder(entity, cameraX, cameraY, zoom) {
        const screenX = (entity.x - cameraX) * zoom + this.canvas.width / 2;
        const screenY = (entity.y - cameraY) * zoom + this.canvas.height / 2;

        this.ctx.fillStyle = entity.entityType === 'transcendent_fae' ? '#ff00ff' : '#ffff00';
        this.ctx.beginPath();
        this.ctx.arc(screenX, screenY, 15 * zoom, 0, Math.PI * 2);
        this.ctx.fill();
      }

      start() {
        this.isPlaying = true;
        requestAnimationFrame((t) => this.animate(t));
      }

      pause() {
        this.isPlaying = false;
      }

      resume() {
        this.isPlaying = true;
      }
    }

    // Global state
    let currentPlayer = null;
    let currentShow = null;
    let currentDirection = 'south';

    const DIRECTIONS = ['south', 'south-west', 'west', 'north-west', 'north', 'north-east', 'east', 'south-east'];

    // Initialize TV grid
    async function initializeShows() {
      const grid = document.getElementById('tvGrid');

      for (const show of SHOWS) {
        const uniqueId = show.id + (show.type === 'sprite' ? '-sprite' : '-recording');
        const showDiv = document.createElement('div');
        showDiv.className = 'tv-show';
        showDiv.innerHTML = `
          <div class="show-title">${show.name}</div>
          <div class="show-status" id="status-${uniqueId}">‚è≥ Loading...</div>
          <div class="canvas-container" id="container-${uniqueId}">
            <div class="loading">‚óÜ LOADING TRANSMISSION ‚óÜ</div>
          </div>
        `;
        showDiv.onclick = () => openPlayer(show);
        grid.appendChild(showDiv);

        // Load preview
        loadShowPreview(show);
      }
    }

    async function loadShowPreview(show) {
      const uniqueId = show.id + (show.type === 'sprite' ? '-sprite' : '-recording');
      const container = document.getElementById(`container-${uniqueId}`);
      const status = document.getElementById(`status-${uniqueId}`);

      try {
        status.textContent = '‚úì READY TO BROADCAST';

        // Create mini canvas for preview
        const canvas = document.createElement('canvas');
        canvas.width = 200;
        canvas.height = 200;
        container.innerHTML = '';
        container.appendChild(canvas);

        if (show.type === 'recording') {
          // Use ReplayRenderer for recordings
          const player = new ReplayRenderer(canvas);

          // Use embedded data if available, otherwise load from path
          const recordingSource = show.recordingData || show.recordingPath;
          await player.loadRecording(recordingSource);
          player.start();
        } else if (show.type === 'combat-replay') {
          // Use CombatReplayRenderer for PixelLab combat replays
          const player = new CombatReplayRenderer(canvas);
          await player.loadCombatReplay(show);
          player.start();
        } else {
          // Use SpriteAnimationPlayer for sprite animations
          const player = new SpriteAnimationPlayer(canvas);
          await player.loadAnimation(show, 'south');
          player.start();
        }

      } catch (error) {
        console.error('Preview error:', error);
        status.textContent = '‚ùå ERROR';
        container.innerHTML = '<div class="loading">SIGNAL LOST</div>';
      }
    }

    async function openPlayer(show) {
      currentShow = show;
      document.getElementById('playerTitle').textContent = show.name;
      document.getElementById('player').classList.add('active');

      // Setup direction selector (only for sprite shows)
      const selector = document.getElementById('directionSelector');
      selector.innerHTML = '';

      if (show.type === 'sprite' && show.directions) {
        show.directions.forEach(dir => {
          const btn = document.createElement('button');
          btn.className = 'direction-btn' + (dir === currentDirection ? ' active' : '');
          btn.textContent = dir;
          btn.onclick = () => changeDirection(dir);
          selector.appendChild(btn);
        });
      }

      // Load and play
      const canvas = document.getElementById('playerCanvas');

      try {
        if (show.type === 'recording') {
          // Use ReplayRenderer for recordings
          currentPlayer = new ReplayRenderer(canvas);

          // Use embedded data if available, otherwise load from path
          const recordingSource = show.recordingData || show.recordingPath;
          await currentPlayer.loadRecording(recordingSource);
          currentPlayer.start();
        } else if (show.type === 'combat-replay') {
          // Use CombatReplayRenderer for PixelLab combat replays
          currentPlayer = new CombatReplayRenderer(canvas);
          await currentPlayer.loadCombatReplay(show);
          currentPlayer.start();
        } else {
          // Use SpriteAnimationPlayer for sprite animations
          currentPlayer = new SpriteAnimationPlayer(canvas);
          await currentPlayer.loadAnimation(show, currentDirection);
          currentPlayer.start();
        }
      } catch (error) {
        showError('Failed to load: ' + error.message);
      }
    }

    async function changeDirection(direction) {
      currentDirection = direction;

      // Update button states
      document.querySelectorAll('.direction-btn').forEach(btn => {
        btn.classList.toggle('active', btn.textContent === direction);
      });

      // Reload animation with new direction
      if (currentPlayer && currentShow) {
        try {
          await currentPlayer.loadAnimation(currentShow, direction);
        } catch (error) {
          showError('Failed to load direction: ' + error.message);
        }
      }
    }

    function closePlayer() {
      document.getElementById('player').classList.remove('active');
      if (currentPlayer) {
        currentPlayer.pause();
      }
    }

    function togglePlayback() {
      if (currentPlayer) {
        if (currentPlayer.isPlaying) {
          currentPlayer.pause();
        } else {
          currentPlayer.resume();
        }
      }
    }

    function showError(message) {
      const errorDiv = document.getElementById('error');
      errorDiv.textContent = message;
      errorDiv.classList.add('active');
      setTimeout(() => errorDiv.classList.remove('active'), 5000);
    }

    // Initialize on load
    console.log('[Interdimensional Cable] Initializing shows...');
    console.log('[Interdimensional Cable] Available shows:', SHOWS.length);
    SHOWS.forEach((show, idx) => {
      const details = show.type === 'sprite' ? `${show.animation}, ${show.frameCount} frames` : 'recording';
      console.log(`[Interdimensional Cable] Show ${idx + 1}: ${show.name} (${details})`);
    });
    initializeShows();
  </script>

  <!-- Load recordings from game world -->
  <script type="module" src="./interdimensional-cable-app.ts"></script>
  <script type="module">
    // Wait for gameLoop to be ready, then load recordings
    let checkInterval = setInterval(() => {
      if (window.__gameLoop && window.loadRecordingsFromWorld) {
        clearInterval(checkInterval);
        console.log('[Interdimensional Cable] GameLoop detected, loading recordings from world...');

        const worldRecordings = window.loadRecordingsFromWorld();
        console.log(`[Interdimensional Cable] Loaded ${worldRecordings.length} recordings from world`);

        // Add world recordings to SHOWS array
        worldRecordings.forEach(show => {
          SHOWS.push(show);
        });

        // Add new shows to grid
        if (worldRecordings.length > 0) {
          console.log('[Interdimensional Cable] Adding world recordings to grid...');
          const grid = document.getElementById('tvGrid');
          if (grid) {
            worldRecordings.forEach(show => {
              const uniqueId = show.id + '-recording';
              const showDiv = document.createElement('div');
              showDiv.className = 'tv-show';
              showDiv.innerHTML = `
                <div class="show-title">${show.name}</div>
                <div class="show-status" id="status-${uniqueId}">‚è≥ Loading...</div>
                <div class="canvas-container" id="container-${uniqueId}">
                  <div class="loading">‚óÜ LOADING TRANSMISSION ‚óÜ</div>
                </div>
              `;
              showDiv.onclick = () => openPlayer(show);
              grid.appendChild(showDiv);

              // Load preview
              loadShowPreview(show);
            });
          }
        }
      }
    }, 500); // Check every 500ms

    // Stop checking after 10 seconds
    setTimeout(() => {
      clearInterval(checkInterval);
      console.log('[Interdimensional Cable] Stopped waiting for gameLoop');
    }, 10000);
  </script>
</body>
</html>
