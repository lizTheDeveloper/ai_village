/**
 * GameIntrospectionAPI - Runtime introspection and entity queries
 *
 * Provides schema-aware entity queries with caching and filtering.
 * Builds on ComponentRegistry to provide runtime access to entity data
 * with schema validation and visibility filtering.
 *
 * Features:
 * - Entity queries with component filtering
 * - Schema-aware serialization
 * - Visibility level filtering
 * - Tick-based result caching
 * - SimulationScheduler integration
 * - Bounds-based spatial queries
 */

import type { Entity, World } from '@ai-village/core';
import type { ComponentType } from '@ai-village/core';
import { ComponentRegistry } from '../registry/ComponentRegistry.js';
import { MutationService } from '../mutation/MutationService.js';
import { ValidationService } from '../mutation/ValidationService.js';
import { IntrospectionCache } from '../IntrospectionCache.js';
import type { ComponentSchema, Component } from '../types/index.js';
import type { Visibility } from '../types/VisibilityTypes.js';
import { SimulationScheduler } from '@ai-village/core';
import type {
  SafeMutationRequest,
  SafeMutationResult,
  BatchMutationResult,
  UndoResult,
  RedoResult,
  WatchOptions,
  UnsubscribeFunction,
  EntityChangeEvent,
  MutationHistoryEntry,
  TriggerBehaviorRequest,
  BehaviorResult,
  SnapshotId,
  EntitySnapshot,
  EntityState,
  SnapshotMetadata,
  RestoreResult,
} from '../types/IntrospectionTypes.js';

// MetricsStreamClient type (avoid importing to prevent circular dependency)
type MetricsStreamClient = any;

/**
 * Query options for filtering entities
 */
export interface EntityQueryOptions {
  /** Component types to filter by (AND logic) */
  withComponents?: ComponentType[];

  /** Bounding box for spatial filtering */
  bounds?: {
    minX: number;
    minY: number;
    maxX: number;
    maxY: number;
  };

  /** Only return entities in active simulation (uses SimulationScheduler) */
  activeOnly?: boolean;

  /** Pagination offset */
  offset?: number;

  /** Pagination limit */
  limit?: number;
}

/**
 * Options for entity retrieval
 */
export interface GetEntityOptions {
  /** Visibility level to filter components by */
  visibilityLevel?: keyof Visibility;

  /** Include components without schemas (default: false) */
  includeUnregistered?: boolean;
}

/**
 * Options for schema listing
 */
export interface ListSchemasOptions {
  /** Filter by category */
  category?: string;

  /** Filter by mutability level */
  mutability?: 'readonly' | 'mutable';
}

/**
 * Entity data with metadata
 */
export interface EnrichedEntity {
  id: string;
  components: Record<string, unknown>;
  metadata: {
    simulationMode?: string;
    lastUpdate?: number;
    cacheHit: boolean;
  };
}

/**
 * Query result with pagination metadata
 */
export interface QueryResult {
  entities: EnrichedEntity[];
  total: number;
  offset: number;
  limit: number;
  cacheHit: boolean;
}

/**
 * Entity watcher subscription
 */
interface EntityWatcher {
  /** Watcher options */
  options: WatchOptions;

  /** Last notification time (for throttling) */
  lastNotified: number;

  /** ID for this watcher */
  id: string;
}

/**
 * GameIntrospectionAPI provides runtime entity introspection
 */
export class GameIntrospectionAPI {
  private world: World;
  private componentRegistry: typeof ComponentRegistry;
  private mutationService: typeof MutationService;
  private metricsAPI: any; // MetricsAPI type (avoid circular dependency)
  private liveEntityAPI: any; // LiveEntityAPI type (avoid circular dependency)
  private cache: IntrospectionCache<EnrichedEntity>;

  // Entity watching
  private entityWatchers: Map<string, Set<EntityWatcher>>;
  private nextWatcherId: number;

  constructor(
    world: World,
    componentRegistry: typeof ComponentRegistry,
    mutationService: typeof MutationService,
    metricsAPI: any,
    liveEntityAPI: any
  ) {
    this.world = world;
    this.componentRegistry = componentRegistry;
    this.mutationService = mutationService;
    this.metricsAPI = metricsAPI;
    this.liveEntityAPI = liveEntityAPI;
    this.cache = new IntrospectionCache<EnrichedEntity>(20); // 20 ticks = 1 second
    this.entityWatchers = new Map();
    this.nextWatcherId = 0;
  }

  /**
   * Attach to MetricsStreamClient to handle queries and actions
   * @param client - MetricsStreamClient instance
   */
  attach(client: MetricsStreamClient): void {
    // Delegate to LiveEntityAPI for now
    // In the future, we can add introspection-specific queries here
    if (this.liveEntityAPI && typeof this.liveEntityAPI.attach === 'function') {
      this.liveEntityAPI.attach(client);
    }
  }

  /**
   * Get a single entity with schema-validated components
   *
   * @param entityId - Entity ID to retrieve
   * @param options - Retrieval options
   * @returns Enriched entity data or null if not found
   */
  getEntity(entityId: string, options: GetEntityOptions = {}): EnrichedEntity | null {
    const cacheKey = this._getCacheKey(entityId, options.visibilityLevel);

    // Check cache
    const cached = this.cache.get(cacheKey);
    if (cached) {
      return { ...cached, metadata: { ...cached.metadata, cacheHit: true } };
    }

    const entity = this.world.getEntity(entityId);
    if (!entity) {
      return null;
    }

    // Get simulation mode if available
    const simulationMode = this.getEntitySimulationMode(entity);
    const lastUpdate = this.getEntityLastUpdate(entity);

    // Serialize components with schema awareness
    const components: Record<string, unknown> = {};
    const visibilityLevel = options.visibilityLevel;

    for (const [componentType, componentData] of entity.components.entries()) {
      const schema = this.componentRegistry.get(componentType);

      // Skip unregistered components unless explicitly requested
      if (!schema && !options.includeUnregistered) {
        continue;
      }

      // Filter by visibility level if specified
      if (visibilityLevel && schema) {
        if (!this.isComponentVisible(schema, visibilityLevel)) {
          continue;
        }
      }

      // Serialize the component
      components[componentType] = this.serializeComponent(componentData, schema);
    }

    const result: EnrichedEntity = {
      id: entityId,
      components,
      metadata: {
        simulationMode,
        lastUpdate,
        cacheHit: false,
      },
    };

    // Cache the result
    this.cache.set(cacheKey, result, entityId);

    return result;
  }

  /**
   * Query entities with filters
   *
   * @param query - Query options
   * @returns Query result with pagination metadata
   */
  queryEntities(query: EntityQueryOptions = {}): QueryResult {
    // Note: Query results are not cached in IntrospectionCache since they
    // don't map to a single entity. Individual entity results are cached via getEntity().

    // Build entity query
    let entityQuery = this.world.query();

    // Add component filters
    if (query.withComponents && query.withComponents.length > 0) {
      for (const componentType of query.withComponents) {
        entityQuery = entityQuery.with(componentType);
      }
    }

    // Execute query
    let entities = entityQuery.executeEntities();

    // Apply bounds filtering if specified
    if (query.bounds) {
      entities = entities.filter((entity) => {
        const position = entity.components.get('position') as
          | { x: number; y: number }
          | undefined;
        if (!position) return false;

        return (
          position.x >= query.bounds!.minX &&
          position.x <= query.bounds!.maxX &&
          position.y >= query.bounds!.minY &&
          position.y <= query.bounds!.maxY
        );
      });
    }

    // Apply SimulationScheduler filtering if requested
    if (query.activeOnly) {
      const scheduler = (this.world as any).simulationScheduler as
        | SimulationScheduler
        | undefined;
      if (scheduler) {
        entities = scheduler.filterActiveEntities(Array.from(entities), this.world.tick);
      }
    }

    const total = entities.length;

    // Apply pagination
    const offset = query.offset || 0;
    const limit = query.limit || 100;
    const paginatedEntities = entities.slice(offset, offset + limit);

    // Enrich entities
    const enrichedEntities: EnrichedEntity[] = paginatedEntities
      .map((entity) => this.getEntity(entity.id, {}))
      .filter((e): e is EnrichedEntity => e !== null);

    const result: QueryResult = {
      entities: enrichedEntities,
      total,
      offset,
      limit,
      cacheHit: false, // Query results themselves aren't cached, but entities within are
    };

    return result;
  }

  /**
   * Get component schema
   *
   * @param type - Component type
   * @returns Component schema or undefined if not registered
   */
  getComponentSchema(type: string): ComponentSchema | undefined {
    return this.componentRegistry.get(type);
  }

  /**
   * List all registered schemas
   *
   * @param options - Filtering options
   * @returns Array of matching schemas
   */
  listSchemas(options: ListSchemasOptions = {}): ComponentSchema[] {
    let schemas = this.componentRegistry.getAll();

    // Filter by category if specified
    if (options.category) {
      schemas = schemas.filter((schema) => schema.category === options.category);
    }

    // Filter by mutability if specified
    if (options.mutability) {
      schemas = schemas.filter((schema) => {
        // Check if any field has the specified mutability
        for (const field of Object.values(schema.fields)) {
          if (options.mutability === 'readonly' && !field.mutable) {
            return true;
          }
          if (options.mutability === 'mutable' && field.mutable) {
            return true;
          }
        }
        return false;
      });
    }

    return schemas;
  }

  /**
   * Clear the cache (useful for testing or manual refresh)
   */
  clearCache(): void {
    this.cache.clear();
  }

  /**
   * Get cache statistics
   */
  getCacheStats() {
    return this.cache.getStats();
  }

  /**
   * Update cache tick (should be called each game tick)
   * @param tick - Current game tick
   */
  onTick(tick: number): void {
    this.cache.onTick(tick);
  }

  // ============================================================================
  // Observability Methods (Watching & History)
  // ============================================================================

  /**
   * Watch an entity for changes.
   *
   * Subscribes to mutation events for a specific entity. When the entity's
   * components are mutated, the onChange callback will be invoked with details
   * about the changes.
   *
   * Options allow filtering by specific components or fields, and throttling
   * notifications to reduce callback frequency.
   *
   * @param entityId - Entity ID to watch
   * @param options - Watch options with onChange callback
   * @returns Unsubscribe function to stop watching
   *
   * @example
   * ```typescript
   * // Watch all changes to an entity
   * const unsubscribe = api.watchEntity('agent-uuid', {
   *   onChange: (event) => {
   *     console.log(`Entity ${event.entityId} changed at tick ${event.tick}`);
   *     event.changes.forEach(change => {
   *       console.log(`  ${change.componentType}.${change.field}: ${change.oldValue} -> ${change.newValue}`);
   *     });
   *   }
   * });
   *
   * // Watch only specific components
   * const unsubscribe = api.watchEntity('agent-uuid', {
   *   components: ['needs', 'health'],
   *   onChange: (event) => { ... }
   * });
   *
   * // Watch with throttling (max once per second)
   * const unsubscribe = api.watchEntity('agent-uuid', {
   *   onChange: (event) => { ... },
   *   throttle: 1000
   * });
   *
   * // Stop watching
   * unsubscribe();
   * ```
   */
  watchEntity(entityId: string, options: WatchOptions): UnsubscribeFunction {
    // Create watcher
    const watcherId = `watcher-${this.nextWatcherId++}`;
    const watcher: EntityWatcher = {
      id: watcherId,
      options,
      lastNotified: 0,
    };

    // Add to entity watchers map
    if (!this.entityWatchers.has(entityId)) {
      this.entityWatchers.set(entityId, new Set());
    }
    this.entityWatchers.get(entityId)!.add(watcher);

    // Return unsubscribe function
    return () => {
      const watchers = this.entityWatchers.get(entityId);
      if (watchers) {
        watchers.delete(watcher);
        // Clean up empty sets
        if (watchers.size === 0) {
          this.entityWatchers.delete(entityId);
        }
      }
    };
  }

  /**
   * Get mutation history from undo/redo stacks.
   *
   * Returns a list of mutations that have been performed, optionally filtered
   * by entity ID or component type. The history includes both undone and
   * non-undone mutations.
   *
   * Note: This accesses the MutationService's internal undo/redo stacks,
   * which have a limited size (default 50 mutations).
   *
   * @param options - Filter and pagination options
   * @returns Array of mutation history entries
   *
   * @example
   * ```typescript
   * // Get last 10 mutations for an entity
   * const history = await api.getMutationHistory({
   *   entityId: 'agent-uuid',
   *   limit: 10
   * });
   *
   * // Get all mutations for a component type
   * const history = await api.getMutationHistory({
   *   componentType: 'needs'
   * });
   *
   * // Get all mutations
   * const history = await api.getMutationHistory({});
   * ```
   */
  async getMutationHistory(options?: {
    entityId?: string;
    componentType?: string;
    limit?: number;
  }): Promise<MutationHistoryEntry[]> {
    const limit = options?.limit || 100;
    const history: MutationHistoryEntry[] = [];

    // Access the private instance to get undo/redo stacks
    // We need to access the internal state, which requires reflection
    const mutationServiceInstance = (this.mutationService as any).getInstance?.();
    if (!mutationServiceInstance) {
      // If we can't access the instance, return empty history
      return history;
    }

    const undoStack = mutationServiceInstance.undoStack as any;
    if (!undoStack) {
      return history;
    }

    // Get commands from both undo and redo stacks
    const undoCommands = (undoStack.undoStack || []) as any[];
    const redoCommands = (undoStack.redoStack || []) as any[];

    // Process undo stack (not undone)
    for (const command of undoCommands) {
      // Filter by entity ID if specified
      if (options?.entityId && command.entityId !== options.entityId) {
        continue;
      }

      // Filter by component type if specified
      if (options?.componentType && command.componentType !== options.componentType) {
        continue;
      }

      history.push({
        id: `mutation-${command.entityId}-${command.componentType}-${command.fieldName}`,
        entityId: command.entityId,
        componentType: command.componentType,
        field: command.fieldName,
        oldValue: command.oldValue,
        newValue: command.newValue,
        tick: this.world.tick, // We don't have the exact tick, use current
        source: 'system', // We don't have the source in the command
        undone: false,
      });
    }

    // Process redo stack (undone mutations)
    for (const command of redoCommands) {
      // Filter by entity ID if specified
      if (options?.entityId && command.entityId !== options.entityId) {
        continue;
      }

      // Filter by component type if specified
      if (options?.componentType && command.componentType !== options.componentType) {
        continue;
      }

      history.push({
        id: `mutation-${command.entityId}-${command.componentType}-${command.fieldName}`,
        entityId: command.entityId,
        componentType: command.componentType,
        field: command.fieldName,
        oldValue: command.oldValue,
        newValue: command.newValue,
        tick: this.world.tick, // We don't have the exact tick, use current
        source: 'system', // We don't have the source in the command
        undone: true,
      });
    }

    // Apply limit
    return history.slice(-limit);
  }

  /**
   * Notify watchers about entity changes.
   * Called internally when mutations occur.
   *
   * @param entityId - Entity that changed
   * @param componentType - Component that changed
   * @param field - Field that changed
   * @param oldValue - Previous value
   * @param newValue - New value
   */
  private notifyWatchers(
    entityId: string,
    componentType: string,
    field: string,
    oldValue: unknown,
    newValue: unknown
  ): void {
    const watchers = this.entityWatchers.get(entityId);
    if (!watchers || watchers.size === 0) {
      return;
    }

    const now = Date.now();
    const event: EntityChangeEvent = {
      entityId,
      tick: this.world.tick,
      changes: [
        {
          componentType,
          field,
          oldValue,
          newValue,
        },
      ],
    };

    for (const watcher of watchers) {
      // Check if we should filter this change
      if (watcher.options.components && watcher.options.components.length > 0) {
        if (!watcher.options.components.includes(componentType)) {
          continue;
        }
      }

      if (watcher.options.fields && watcher.options.fields.length > 0) {
        if (!watcher.options.fields.includes(field)) {
          continue;
        }
      }

      // Check throttling
      if (watcher.options.throttle) {
        const timeSinceLastNotification = now - watcher.lastNotified;
        if (timeSinceLastNotification < watcher.options.throttle) {
          continue;
        }
      }

      // Update last notified time
      watcher.lastNotified = now;

      // Call the onChange callback
      try {
        watcher.options.onChange(event);
      } catch (error) {
        console.error('[GameIntrospectionAPI] Error in entity watcher callback:', error);
      }
    }
  }

  // ============================================================================
  // Behavioral Control Methods
  // ============================================================================

  /**
   * Trigger a behavior on an entity.
   *
   * This method provides comprehensive behavior triggering with:
   * - Entity and behavior validation
   * - Behavior queue manipulation
   * - Cache invalidation
   * - Metrics tracking
   *
   * @param request - Behavior trigger request
   * @returns Behavior result with success status and state
   *
   * @example
   * ```typescript
   * const result = await api.triggerBehavior({
   *   entityId: 'agent-uuid',
   *   behavior: 'gather',
   *   params: { targetEntityId: 'tree-uuid' },
   *   validate: true
   * });
   *
   * if (result.success) {
   *   console.log(`Triggered behavior: ${result.behavior}`);
   * }
   * ```
   */
  async triggerBehavior(request: TriggerBehaviorRequest): Promise<BehaviorResult> {
    const startTime = performance.now();
    const validate = request.validate !== false; // Default true

    try {
      // Get entity
      const entity = this.world.getEntity(request.entityId);
      if (!entity) {
        return {
          success: false,
          behavior: request.behavior,
          error: `Entity not found: ${request.entityId}`,
        };
      }

      // Verify entity has agent component (required for behaviors)
      const agent = entity.getComponent('agent') as {
        behaviorQueue?: Array<{
          behavior: string;
          behaviorState?: Record<string, unknown>;
          priority?: string;
          repeats?: number;
          currentRepeat?: number;
          label?: string;
          startedAt?: number;
        }>;
        currentQueueIndex?: number;
        behaviorCompleted?: boolean;
      } | undefined;

      if (!agent) {
        return {
          success: false,
          behavior: request.behavior,
          error: `Entity ${request.entityId} does not have agent component`,
        };
      }

      // Validate behavior if requested
      if (validate) {
        const validBehaviors = [
          'wander', 'idle', 'follow', 'flee', 'follow_agent', 'follow_reporting_target',
          'talk', 'pick', 'gather', 'harvest', 'gather_seeds', 'seek_food',
          'explore', 'approach', 'observe', 'rest', 'work', 'help', 'build',
          'plan_build', 'craft', 'eat', 'seek_sleep', 'forced_sleep', 'flee_danger',
          'flee_to_home', 'seek_water', 'seek_shelter', 'deposit_items',
          'seek_warmth', 'seek_cooling', 'call_meeting', 'attend_meeting',
          'till', 'farm', 'plant', 'water', 'fertilize', 'navigate',
          'explore_frontier', 'explore_spiral', 'follow_gradient', 'tame_animal',
          'house_animal', 'trade', 'initiate_combat', 'hunt', 'butcher',
          'cast_spell', 'pray', 'meditate', 'group_pray', 'repair', 'upgrade',
          'material_transport', 'tile_build', 'research', 'set_priorities',
          'set_personal_goal', 'set_medium_term_goal', 'set_group_goal',
          'sleep_until_queue_complete', 'player_controlled'
        ];

        if (!validBehaviors.includes(request.behavior)) {
          return {
            success: false,
            behavior: request.behavior,
            error: `Invalid behavior type: ${request.behavior}. Must be one of: ${validBehaviors.join(', ')}`,
          };
        }
      }

      // Initialize behavior queue if it doesn't exist
      if (!agent.behaviorQueue) {
        agent.behaviorQueue = [];
      }

      // Clear existing queue and add new behavior
      agent.behaviorQueue = [{
        behavior: request.behavior,
        behaviorState: request.params,
        priority: 'high',
        startedAt: this.world.tick,
        label: `Manually triggered: ${request.behavior}`,
      }];

      // Reset queue state
      agent.currentQueueIndex = 0;
      agent.behaviorCompleted = false;

      // Invalidate entity cache
      this.cache.invalidate(request.entityId);

      // Track metrics event if metricsAPI available
      if (this.metricsAPI && typeof this.metricsAPI.trackEvent === 'function') {
        this.metricsAPI.trackEvent('behavior_trigger', {
          entityId: request.entityId,
          behavior: request.behavior,
          latency: performance.now() - startTime,
        });
      }

      return {
        success: true,
        behavior: request.behavior,
        state: {
          queueIndex: 0,
          behaviorState: request.params,
          startedAt: this.world.tick,
        },
      };

    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);

      return {
        success: false,
        behavior: request.behavior,
        error: errorMsg,
      };
    }
  }

  // ============================================================================
  // Mutation Methods (Validated, Tracked, Reversible)
  // ============================================================================

  /**
   * Mutate a single component field with validation, tracking, and undo support.
   *
   * This method provides comprehensive mutation with:
   * - Schema-based validation (type, range, mutability)
   * - Automatic undo/redo support
   * - Cache invalidation
   * - Metrics tracking
   *
   * @param mutation - Mutation request
   * @returns Mutation result with success status, old/new values, and metrics
   *
   * @example
   * ```typescript
   * const result = await api.mutateField({
   *   entityId: 'agent-uuid',
   *   componentType: 'needs',
   *   field: 'hunger',
   *   value: 0.5,
   *   reason: 'Admin action: feed agent'
   * });
   *
   * if (result.success) {
   *   console.log(`Changed ${result.oldValue} -> ${result.newValue}`);
   *   console.log(`Latency: ${result.metrics.latency}ms`);
   * }
   * ```
   */
  async mutateField(mutation: SafeMutationRequest): Promise<SafeMutationResult> {
    const startTime = performance.now();
    const validate = mutation.validate !== false; // Default true
    const source = mutation.source || 'system';

    try {
      // Get entity
      const entity = this.world.getEntity(mutation.entityId);
      if (!entity) {
        return {
          success: false,
          oldValue: undefined,
          newValue: undefined,
          validationErrors: ['Entity does not exist'],
          metrics: {
            latency: performance.now() - startTime,
            cacheInvalidations: 0,
          },
        };
      }

      // Validate if requested
      if (validate) {
        const validationResult = this.validateMutation(
          mutation.componentType,
          mutation.field,
          mutation.value
        );

        if (!validationResult.valid) {
          return {
            success: false,
            oldValue: undefined,
            newValue: undefined,
            validationErrors: validationResult.error ? [validationResult.error] : [],
            metrics: {
              latency: performance.now() - startTime,
              cacheInvalidations: 0,
            },
          };
        }
      }

      // Get old value before mutation
      const component = entity.getComponent(mutation.componentType);
      const oldValue = component ? (component as any)[mutation.field] : undefined;

      // Count caches before invalidation
      const cacheStatsBefore = this.cache.getStats();

      // Apply mutation via MutationService (handles validation, undo, events)
      // Note: MutationService defines its own Entity interface which is compatible
      const mutationResult = MutationService.mutate(
        entity as any, // Type cast needed due to interface mismatch
        mutation.componentType,
        mutation.field,
        mutation.value,
        source
      );

      // Count cache invalidations (cache entries removed)
      const cacheStatsAfter = this.cache.getStats();
      const cacheInvalidations = cacheStatsBefore.invalidations < cacheStatsAfter.invalidations
        ? cacheStatsAfter.invalidations - cacheStatsBefore.invalidations
        : 0;

      // Invalidate this entity's cache
      this.cache.invalidate(mutation.entityId);

      const latency = performance.now() - startTime;

      if (!mutationResult.success) {
        return {
          success: false,
          oldValue,
          newValue: mutation.value,
          validationErrors: mutationResult.error ? [mutationResult.error] : [],
          metrics: {
            latency,
            cacheInvalidations,
          },
        };
      }

      // Track metrics event if metricsAPI available
      if (this.metricsAPI && typeof this.metricsAPI.trackEvent === 'function') {
        this.metricsAPI.trackEvent('mutation', {
          entityId: mutation.entityId,
          componentType: mutation.componentType,
          field: mutation.field,
          latency,
          reason: mutation.reason,
          source,
        });
      }

      // Notify entity watchers
      this.notifyWatchers(
        mutation.entityId,
        mutation.componentType,
        mutation.field,
        oldValue,
        mutation.value
      );

      return {
        success: true,
        oldValue,
        newValue: mutation.value,
        metrics: {
          latency,
          cacheInvalidations: cacheInvalidations + 1, // +1 for explicit invalidation
        },
      };

    } catch (error) {
      const latency = performance.now() - startTime;
      const errorMsg = error instanceof Error ? error.message : String(error);

      return {
        success: false,
        oldValue: undefined,
        newValue: undefined,
        validationErrors: [errorMsg],
        metrics: {
          latency,
          cacheInvalidations: 0,
        },
      };
    }
  }

  /**
   * Mutate multiple fields in a batch with atomic rollback on failure.
   *
   * All mutations are validated before any are applied. If any mutation
   * fails during execution, all previous mutations are rolled back using
   * the undo stack.
   *
   * This provides atomic batch semantics: either all mutations succeed,
   * or none are applied.
   *
   * @param mutations - Array of mutation requests
   * @returns Batch result with individual results and rollback status
   *
   * @example
   * ```typescript
   * const result = await api.mutateBatch([
   *   { entityId: 'agent1', componentType: 'needs', field: 'hunger', value: 0.5 },
   *   { entityId: 'agent2', componentType: 'needs', field: 'energy', value: 0.8 }
   * ]);
   *
   * if (result.success) {
   *   console.log(`${result.successCount} mutations applied`);
   * } else {
   *   console.log(`Batch failed, rolled back: ${result.rolledBack}`);
   * }
   * ```
   */
  async mutateBatch(mutations: SafeMutationRequest[]): Promise<BatchMutationResult> {
    const results: SafeMutationResult[] = [];
    let successCount = 0;
    let failureCount = 0;
    let rolledBack = false;

    try {
      // Apply all mutations sequentially
      for (const mutation of mutations) {
        const result = await this.mutateField(mutation);
        results.push(result);

        if (result.success) {
          successCount++;
        } else {
          failureCount++;

          // Rollback all mutations in this batch
          const mutationsApplied = results.length - 1; // Exclude current failed one
          if (mutationsApplied > 0) {
            // Undo all mutations we just applied
            await this.undo(mutationsApplied);
            rolledBack = true;
          }

          // Stop processing remaining mutations
          break;
        }
      }

      return {
        success: failureCount === 0,
        results,
        successCount,
        failureCount,
        rolledBack,
        error: failureCount > 0 ? `Batch failed with ${failureCount} error(s)` : undefined,
      };

    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);

      return {
        success: false,
        results,
        successCount,
        failureCount: mutations.length - successCount,
        rolledBack,
        error: errorMsg,
      };
    }
  }

  /**
   * Undo the last N mutations.
   *
   * Reverses mutations in reverse order (most recent first).
   * Uses MutationService's undo stack to restore previous values.
   * Automatically invalidates render caches for affected entities.
   *
   * @param count - Number of mutations to undo (default: 1)
   * @returns Undo result with success status and count
   *
   * @example
   * ```typescript
   * const result = await api.undo(3); // Undo last 3 mutations
   * if (result.success) {
   *   console.log(`Undone ${result.count} mutations`);
   * }
   * ```
   */
  async undo(count: number = 1): Promise<UndoResult> {
    if (count < 1) {
      return {
        success: false,
        count: 0,
        error: 'Count must be at least 1',
      };
    }

    if (!MutationService.canUndo()) {
      return {
        success: false,
        count: 0,
        error: 'Nothing to undo',
      };
    }

    try {
      let undoneCount = 0;

      // Undo mutations one by one
      for (let i = 0; i < count; i++) {
        if (!MutationService.canUndo()) {
          break;
        }

        const success = MutationService.undo();
        if (success) {
          undoneCount++;

          // Invalidate entire cache since we don't know which entities were affected
          this.cache.clear();
        } else {
          break;
        }
      }

      return {
        success: undoneCount > 0,
        count: undoneCount,
      };

    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        count: 0,
        error: errorMsg,
      };
    }
  }

  /**
   * Redo the last N undone mutations.
   *
   * Re-applies mutations that were undone, in original order.
   * Uses MutationService's redo stack to restore undone changes.
   * Automatically invalidates render caches for affected entities.
   *
   * @param count - Number of mutations to redo (default: 1)
   * @returns Redo result with success status and count
   *
   * @example
   * ```typescript
   * const result = await api.redo(2); // Redo last 2 undone mutations
   * if (result.success) {
   *   console.log(`Redone ${result.count} mutations`);
   * }
   * ```
   */
  async redo(count: number = 1): Promise<RedoResult> {
    if (count < 1) {
      return {
        success: false,
        count: 0,
        error: 'Count must be at least 1',
      };
    }

    if (!MutationService.canRedo()) {
      return {
        success: false,
        count: 0,
        error: 'Nothing to redo',
      };
    }

    try {
      let redoneCount = 0;

      // Redo mutations one by one
      for (let i = 0; i < count; i++) {
        if (!MutationService.canRedo()) {
          break;
        }

        const success = MutationService.redo();
        if (success) {
          redoneCount++;

          // Invalidate entire cache since we don't know which entities were affected
          this.cache.clear();
        } else {
          break;
        }
      }

      return {
        success: redoneCount > 0,
        count: redoneCount,
      };

    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        count: 0,
        error: errorMsg,
      };
    }
  }

  // ============================================================================
  // Private helper methods
  // ============================================================================

  /**
   * Generate consistent cache key
   * @param entityId - Entity ID
   * @param visibilityLevel - Visibility level filter
   * @returns Cache key string
   */
  private _getCacheKey(entityId: string, visibilityLevel?: keyof Visibility): string {
    return `entity:${entityId}:visibility=${visibilityLevel || 'all'}`;
  }

  /**
   * Get entity simulation mode
   */
  private getEntitySimulationMode(entity: Entity): string | undefined {
    // Check if entity has simulation mode metadata
    // This would come from SimulationScheduler
    const scheduler = (this.world as any).simulationScheduler as
      | SimulationScheduler
      | undefined;
    if (!scheduler) {
      return undefined;
    }

    // Determine mode based on components
    for (const [componentType] of entity.components.entries()) {
      const config = (SimulationScheduler as any).getSimulationConfig?.(componentType);
      if (config) {
        return config.mode;
      }
    }

    return undefined;
  }

  /**
   * Get entity last update tick
   */
  private getEntityLastUpdate(entity: Entity): number | undefined {
    // This would come from SimulationScheduler's lastUpdateTick map
    // For now, return undefined as we don't have direct access
    return undefined;
  }

  /**
   * Check if a component is visible at a given level
   */
  private isComponentVisible(
    schema: ComponentSchema,
    level: keyof Visibility
  ): boolean {
    // Check if any field is visible at this level
    for (const field of Object.values(schema.fields)) {
      if (field.visibility?.[level]) {
        return true;
      }
    }
    return false;
  }

  /**
   * Serialize a component with schema awareness
   */
  private serializeComponent(
    component: unknown,
    schema?: ComponentSchema
  ): unknown {
    if (component === null || component === undefined) {
      return component;
    }

    if (typeof component !== 'object') {
      return component;
    }

    // Handle arrays
    if (Array.isArray(component)) {
      return component.map((item) => this.serializeComponent(item, undefined));
    }

    // Handle Maps
    if (component instanceof Map) {
      const obj: Record<string, unknown> = {};
      for (const [k, v] of component.entries()) {
        obj[String(k)] = this.serializeComponent(v, undefined);
      }
      return obj;
    }

    // Handle Sets
    if (component instanceof Set) {
      return Array.from(component).map((item) =>
        this.serializeComponent(item, undefined)
      );
    }

    // Handle plain objects
    const result: Record<string, unknown> = {};
    for (const [key, value] of Object.entries(
      component as Record<string, unknown>
    )) {
      // Skip functions
      if (typeof value === 'function') continue;

      // Use schema to guide serialization if available
      if (schema && schema.fields[key]) {
        const fieldSchema = schema.fields[key];
        // Could apply field-specific serialization here
        result[key] = this.serializeComponent(value, undefined);
      } else {
        result[key] = this.serializeComponent(value, undefined);
      }
    }
    return result;
  }

  /**
   * Validate a mutation request against component schema.
   *
   * This method provides comprehensive validation:
   * - Schema exists for component type
   * - Field exists in schema
   * - Field is mutable
   * - Value type matches schema
   * - Value satisfies range/enum constraints
   *
   * @param componentType - Component type to validate
   * @param field - Field name to validate
   * @param value - Value to validate
   * @returns Validation result with error message if invalid
   */
  private validateMutation(
    componentType: string,
    field: string,
    value: unknown
  ): { valid: boolean; error?: string } {
    // Check if schema exists
    const schema = this.componentRegistry.get(componentType);
    if (!schema) {
      return {
        valid: false,
        error: `No schema registered for component type '${componentType}'`,
      };
    }

    // Use ValidationService for full validation (type, range, mutability, etc.)
    return ValidationService.validate(schema, field, value, false);
  }
}
