import { describe, it, expect, beforeEach, vi } from 'vitest';
import { WorldImpl } from '../../ecs/World.js';
import { EventBusImpl } from '../../events/EventBus.js';
import { SoilSystem, type Tile, type BiomeType } from '../../systems/SoilSystem.js';
import { parseAction } from '../AgentAction.js';
import { createAgentComponent } from '../../components/AgentComponent.js';
import { createPositionComponent } from '../../components/PositionComponent.js';
import type { Entity } from '../../ecs/Entity.js';

/**
 * ActionHandler Integration Tests for Till Action
 *
 * These tests verify the full integration of till actions:
 * - LLM parsing of till commands
 * - ActionHandler processing till actions
 * - Position validation
 * - Tile retrieval from world
 * - SoilSystem.tillTile execution
 * - Event emission
 * - Error handling
 *
 * Tests should FAIL initially (TDD red phase) until ActionHandler is updated.
 */
describe('ActionHandler - Till Action Integration', () => {
  let world: WorldImpl;
  let eventBus: EventBusImpl;
  let soilSystem: SoilSystem;
  let agent: Entity;

  beforeEach(() => {
    eventBus = new EventBusImpl();
    world = new WorldImpl(eventBus);
    soilSystem = new SoilSystem();

    // Create a test agent
    agent = world.createEntity();
    (agent as any).addComponent(createPositionComponent(10, 10));
    (agent as any).addComponent(createAgentComponent('idle'));
  });

  /**
   * Helper function to create a test tile
   */
  function createTile(terrain: string, biome: BiomeType): Tile {
    return {
      terrain,
      moisture: 50,
      fertility: 50,
      biome,
      tilled: false,
      plantability: 0,
      nutrients: {
        nitrogen: 0,
        phosphorus: 0,
        potassium: 0,
      },
      fertilized: false,
      fertilizerDuration: 0,
      lastWatered: 0,
      composted: false,
    };
  }

  /**
   * Helper to calculate distance between two positions
   */
  function distance(pos1: { x: number; y: number }, pos2: { x: number; y: number }): number {
    const dx = pos2.x - pos1.x;
    const dy = pos2.y - pos1.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  describe('LLM Action Parsing', () => {
    it('should parse "till" keyword to till action', () => {
      const action = parseAction('I will till the soil here');

      expect(action).toBeDefined();
      expect(action?.type).toBe('till');
    });

    it('should parse "tilling" keyword to till action', () => {
      const action = parseAction('I am tilling the field to prepare for planting');

      expect(action).toBeDefined();
      expect(action?.type).toBe('till');
    });

    it('should parse "plow" keyword to till action', () => {
      const action = parseAction('I need to plow the ground');

      expect(action).toBeDefined();
      expect(action?.type).toBe('till');
    });

    it('should parse "plowing" keyword to till action', () => {
      const action = parseAction('I am plowing the field');

      expect(action).toBeDefined();
      expect(action?.type).toBe('till');
    });

    it('should parse "prepare soil" phrase to till action', () => {
      const action = parseAction('I will prepare the soil for farming');

      expect(action).toBeDefined();
      expect(action?.type).toBe('till');
    });

    it('should parse "prepare ground" phrase to till action', () => {
      const action = parseAction('I need to prepare the ground');

      expect(action).toBeDefined();
      expect(action?.type).toBe('till');
    });

    it('should include position in parsed action', () => {
      const action = parseAction('I will till the soil');

      expect(action).toBeDefined();
      if (action?.type === 'till') {
        expect(action.position).toBeDefined();
        expect(typeof action.position.x).toBe('number');
        expect(typeof action.position.y).toBe('number');
      }
    });
  });

  describe('Position Validation', () => {
    it('should validate agent is adjacent to target tile (cardinal direction)', () => {
      const agentPos = { x: 10, y: 10 };
      const targetPos = { x: 10, y: 11 }; // North

      const dist = distance(agentPos, targetPos);

      expect(dist).toBe(1);
      expect(dist).toBeLessThanOrEqual(Math.sqrt(2));
    });

    it('should validate agent is adjacent to target tile (diagonal)', () => {
      const agentPos = { x: 10, y: 10 };
      const targetPos = { x: 11, y: 11 }; // Northeast

      const dist = distance(agentPos, targetPos);

      expect(dist).toBeCloseTo(Math.sqrt(2), 5);
      expect(dist).toBeLessThanOrEqual(Math.sqrt(2));
    });

    it('should reject action if agent is too far from target', () => {
      const agentPos = { x: 10, y: 10 };
      const targetPos = { x: 15, y: 15 }; // 5 tiles away

      const dist = distance(agentPos, targetPos);

      expect(dist).toBeGreaterThan(Math.sqrt(2));
    });

    it('should accept all 8 adjacent positions (including diagonals)', () => {
      const agentPos = { x: 10, y: 10 };
      const adjacentPositions = [
        { x: 10, y: 11 }, // N
        { x: 11, y: 11 }, // NE
        { x: 11, y: 10 }, // E
        { x: 11, y: 9 },  // SE
        { x: 10, y: 9 },  // S
        { x: 9, y: 9 },   // SW
        { x: 9, y: 10 },  // W
        { x: 9, y: 11 },  // NW
      ];

      adjacentPositions.forEach(pos => {
        const dist = distance(agentPos, pos);
        expect(dist).toBeLessThanOrEqual(Math.sqrt(2));
      });
    });
  });

  describe('ActionHandler Processing', () => {
    it('should process till action from agent action queue', () => {
      // This test will fail until ActionHandler is updated
      // Expected behavior:
      // 1. Agent has till action in queue
      // 2. ActionHandler recognizes till action
      // 3. Validates agent position vs target
      // 4. Retrieves tile from world
      // 5. Calls SoilSystem.tillTile
      // 6. Removes action from queue

      const agentComponent = agent.getComponent('agent') as AgentComponent;
      agentComponent.actionQueue.push({ type: 'till', position: { x: 10, y: 11 } });

      // This will fail - ActionHandler doesn't handle till yet
      expect(agentComponent.actionQueue.length).toBe(1);
    });

    it('should validate position before tilling', () => {
      // This test verifies ActionHandler checks distance before executing
      const agentComponent = agent.getComponent('agent') as AgentComponent;
      const farPosition = { x: 50, y: 50 };
      agentComponent.actionQueue.push({ type: 'till', position: farPosition });

      // ActionHandler should reject this action due to distance
      // Test will fail until implemented
      expect(true).toBe(true); // Placeholder
    });

    it('should call SoilSystem.tillTile when action is valid', () => {
      const tile = createTile('grass', 'plains');
      const tillSpy = vi.spyOn(soilSystem, 'tillTile');

      // Mock getting tile from world
      // Then process till action
      soilSystem.tillTile(world, tile, 10, 11);

      expect(tillSpy).toHaveBeenCalledWith(world, tile, 10, 11);
    });

    it('should emit action:completed event when tilling succeeds', () => {
      const handler = vi.fn();
      eventBus.subscribe('action:completed', handler);

      // Process till action successfully
      // Should emit action:completed
      // Test will fail until implemented
      expect(true).toBe(true); // Placeholder
    });

    it('should remove till action from queue after completion', () => {
      const agentComponent = agent.getComponent('agent') as AgentComponent;
      agentComponent.actionQueue.push({ type: 'till', position: { x: 10, y: 11 } });

      // After ActionHandler processes and completes the action
      // actionQueue should be empty
      // Test will fail until implemented
      expect(true).toBe(true); // Placeholder
    });
  });

  describe('Error Handling', () => {
    it('should handle invalid terrain gracefully', () => {
      const tile = createTile('stone', 'mountains');

      // ActionHandler should catch SoilSystem error and handle it
      // Should NOT crash the game
      expect(() => {
        soilSystem.tillTile(world, tile, 10, 11);
      }).toThrow('Cannot till stone terrain');
    });

    it('should emit action:failed event when tilling fails', () => {
      const handler = vi.fn();
      eventBus.subscribe('action:failed', handler);

      // Process till action on invalid terrain
      // Should emit action:failed
      // Test will fail until implemented
      expect(true).toBe(true); // Placeholder
    });

    it('should NOT modify tile state if action fails', () => {
      const tile = createTile('water', 'river');
      const originalTerrain = tile.terrain;

      try {
        soilSystem.tillTile(world, tile, 10, 11);
      } catch {
        // Expected
      }

      expect(tile.terrain).toBe(originalTerrain);
      expect(tile.tilled).toBe(false);
    });

    it('should handle missing tile gracefully', () => {
      // ActionHandler should validate tile exists before calling tillTile
      // If tile is null, should fail gracefully with clear error
      expect(() => {
        soilSystem.tillTile(world, null as any, 10, 11);
      }).toThrow();
    });

    it('should throw clear error for null/undefined parameters (CLAUDE.md)', () => {
      const tile = createTile('grass', 'plains');

      // No silent fallbacks - throw immediately
      expect(() => {
        soilSystem.tillTile(world, null as any, 10, 11);
      }).toThrow();

      expect(() => {
        soilSystem.tillTile(null as any, tile, 10, 11);
      }).toThrow();
    });
  });

  describe('Energy Cost', () => {
    it('should reduce agent energy when tilling', () => {
      const agentComponent = agent.getComponent('agent') as AgentComponent;
      const initialEnergy = agentComponent.energy;

      // Process till action
      // Energy should decrease
      // Test will fail until implemented
      expect(initialEnergy).toBe(100); // Placeholder
    });

    it('should prevent tilling if agent has insufficient energy', () => {
      const agentComponent = agent.getComponent('agent') as AgentComponent;
      agentComponent.energy = 0;

      // ActionHandler should reject till action if energy < cost
      // Test will fail until implemented
      expect(true).toBe(true); // Placeholder
    });
  });

  describe('Skill XP (Future)', () => {
    it('should award farming XP when tilling succeeds', () => {
      // This is a future feature - test as placeholder
      // When skill system exists, tilling should award farming XP
      expect(true).toBe(true); // Placeholder
    });
  });

  describe('Tool Requirements (Future)', () => {
    it('should check for hoe/shovel tool if tool system exists', () => {
      // Future feature - test as placeholder
      // ActionHandler should verify agent has required tool
      expect(true).toBe(true); // Placeholder
    });

    it('should fail tilling if agent lacks required tool', () => {
      // Future feature - test as placeholder
      expect(true).toBe(true); // Placeholder
    });
  });

  describe('Full Integration Flow', () => {
    it('should execute complete till action workflow', () => {
      // This test verifies the ENTIRE flow:
      // 1. LLM returns "I will till the soil"
      // 2. parseAction converts to { type: 'till', position: {...} }
      // 3. Action added to agent's queue
      // 4. ActionHandler picks up action
      // 5. Validates agent position
      // 6. Retrieves tile from world
      // 7. Calls SoilSystem.tillTile
      // 8. Tile state updated (grass â†’ dirt, tilled=true)
      // 9. Events emitted (soil:tilled, action:completed)
      // 10. Action removed from queue

      const llmResponse = 'I will till the soil to prepare for planting';
      const action = parseAction(llmResponse);

      expect(action).toBeDefined();
      expect(action?.type).toBe('till');

      // Rest of workflow will be tested when ActionHandler is implemented
    });
  });

  describe('CLAUDE.md Compliance', () => {
    it('should NOT use fallback position if missing', () => {
      // parseAction should throw or return null if position cannot be determined
      // NO silent { x: 0, y: 0 } fallback
      const action = parseAction('I will till');

      // Implementation should handle missing position explicitly
      // Either throw, return null, or use agent's current position
      expect(action).toBeDefined();
    });

    it('should NOT catch and hide terrain validation errors', () => {
      const tile = createTile('stone', 'mountains');

      // Error should propagate to caller, not be caught silently
      expect(() => {
        soilSystem.tillTile(world, tile, 10, 11);
      }).toThrow('Cannot till stone terrain');
    });

    it('should provide clear error messages for all failure modes', () => {
      const tile = createTile('water', 'river');

      try {
        soilSystem.tillTile(world, tile, 10, 11);
        expect(true).toBe(false); // Should not reach here
      } catch (error: any) {
        expect(error.message).toMatch(/Cannot till/);
        expect(error.message).toContain('water');
        expect(error.message).toContain('(10,11)');
      }
    });
  });
});
