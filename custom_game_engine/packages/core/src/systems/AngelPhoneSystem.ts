/**
 * AngelPhoneSystem - God's Phone Chat Handler
 *
 * Phase 28.6: Angel Communication
 *
 * Manages the "phone" system for deity-angel communication:
 * - Group chat for all angels
 * - 1:1 DMs with individual angels
 * - Custom sub-groups
 * - Rate-limited phone checking by angels
 * - LLM-powered angel responses
 *
 * Key Design:
 * - Angels don't constantly monitor messages
 * - They check their phone at intervals (phoneCheckFrequency)
 * - Player messages queue until angel checks
 * - Angels can respond via LLM when they check messages
 */

import { BaseSystem, type SystemContext } from '../ecs/SystemContext.js';
import type { World } from '../ecs/World.js';
import { type Entity, EntityImpl } from '../ecs/Entity.js';
import {
  type AngelMessagingComponent,
  type ChatRoom,
  type ChatMessage,
  createChatRoom,
  createAngelChatMessage,
  createAngelMessagingComponent,
  generateChatRoomId,
  generateMessageId,
} from '../components/AngelMessagingComponent.js';
import type { AngelComponent } from '../components/AngelComponent.js';

// ============================================================================
// Types
// ============================================================================

/**
 * Phone system state (singleton data stored on World)
 */
export interface AngelPhoneSystemState {
  // Chat rooms
  chatRooms: Map<string, ChatRoom>;

  // Messages by chat room
  messages: Map<string, ChatMessage[]>;

  // Pending messages waiting to be processed by angels
  pendingMessages: Map<string, string[]>; // angelId -> messageIds

  // Last processed tick
  lastUpdateTick: number;
}

/**
 * Message to send
 */
export interface SendMessageRequest {
  chatId: string;
  senderId: string;
  senderType: 'player' | 'angel';
  senderName: string;
  content: string;
  replyToId?: string;
}

/**
 * Angel response generated by LLM
 */
export interface AngelResponse {
  angelId: string;
  chatId: string;
  content: string;
  shouldCreateMemory: boolean;
  memoryContent?: string;
}

// ============================================================================
// Constants
// ============================================================================

/**
 * How often the system processes phone checks (ticks)
 */
const PHONE_SYSTEM_UPDATE_INTERVAL = 20; // Every second at 20 TPS

/**
 * Max messages to keep per chat room
 */
const MAX_MESSAGES_PER_CHAT = 500;

// ============================================================================
// Module-level state (singleton pattern)
// ============================================================================

// Global state storage - persists across system instances
const phoneSystemStates = new Map<string, AngelPhoneSystemState>();

/**
 * Get state key for a world
 * Uses 'default' since World doesn't expose an ID - in practice there's one world per game
 */
function getStateKey(_world: World): string {
  return 'default';
}

// ============================================================================
// System
// ============================================================================

/**
 * AngelPhoneSystem - Handles deity-angel communication
 */
export class AngelPhoneSystem extends BaseSystem {
  public readonly id = 'angel_phone' as const;
  public readonly priority = 180; // After brain systems, before UI
  public readonly requiredComponents = [] as const;
  public readonly activationComponents = ['angel_messaging'] as const;

  protected readonly throttleInterval = PHONE_SYSTEM_UPDATE_INTERVAL;

  /**
   * Initialize the phone system state
   */
  static initializeState(world: World): AngelPhoneSystemState {
    const key = getStateKey(world);
    const state: AngelPhoneSystemState = {
      chatRooms: new Map(),
      messages: new Map(),
      pendingMessages: new Map(),
      lastUpdateTick: 0,
    };

    phoneSystemStates.set(key, state);
    return state;
  }

  /**
   * Get or create phone system state
   */
  static getState(world: World): AngelPhoneSystemState {
    const key = getStateKey(world);
    let state = phoneSystemStates.get(key);
    if (!state) {
      state = AngelPhoneSystem.initializeState(world);
    }
    return state;
  }

  /**
   * Create a group chat for a deity's angels
   */
  static createGroupChat(
    world: World,
    deityId: string,
    deityName: string,
    currentTick: number
  ): ChatRoom {
    const state = AngelPhoneSystem.getState(world);
    const chatId = generateChatRoomId('group', deityId);

    // Check if already exists
    const existing = state.chatRooms.get(chatId);
    if (existing) {
      return existing;
    }

    const room = createChatRoom({
      id: chatId,
      type: 'group',
      name: `${deityName}'s Angels`,
      participants: [deityId],
      currentTick,
    });

    state.chatRooms.set(chatId, room);
    state.messages.set(chatId, []);

    return room;
  }

  /**
   * Create a DM chat between deity and angel
   */
  static createDMChat(
    world: World,
    deityId: string,
    angelId: string,
    angelName: string,
    currentTick: number
  ): ChatRoom {
    const state = AngelPhoneSystem.getState(world);
    const chatId = generateChatRoomId('dm', deityId, angelId);

    // Check if already exists
    const existing = state.chatRooms.get(chatId);
    if (existing) {
      return existing;
    }

    const room = createChatRoom({
      id: chatId,
      type: 'dm',
      name: angelName,
      participants: [deityId, angelId],
      currentTick,
    });

    state.chatRooms.set(chatId, room);
    state.messages.set(chatId, []);

    return room;
  }

  /**
   * Add an angel to the group chat
   */
  static addAngelToGroupChat(world: World, deityId: string, angelId: string): void {
    const state = AngelPhoneSystem.getState(world);
    const chatId = generateChatRoomId('group', deityId);
    const room = state.chatRooms.get(chatId);

    if (room && !room.participants.includes(angelId)) {
      room.participants.push(angelId);
    }
  }

  /**
   * Send a message to a chat
   */
  static sendMessage(
    world: World,
    request: SendMessageRequest,
    currentTick: number
  ): ChatMessage | null {
    const state = AngelPhoneSystem.getState(world);
    const room = state.chatRooms.get(request.chatId);

    if (!room) {
      console.warn(`[AngelPhoneSystem] Chat room not found: ${request.chatId}`);
      return null;
    }

    const message = createAngelChatMessage({
      id: generateMessageId(request.chatId),
      chatId: request.chatId,
      senderId: request.senderId,
      senderType: request.senderType,
      senderName: request.senderName,
      content: request.content,
      currentTick,
      replyToId: request.replyToId,
    });

    // Add to message history
    const messages = state.messages.get(request.chatId) || [];
    messages.push(message);

    // Trim if too many messages
    if (messages.length > MAX_MESSAGES_PER_CHAT) {
      messages.splice(0, messages.length - MAX_MESSAGES_PER_CHAT);
    }

    state.messages.set(request.chatId, messages);

    // Update room stats
    room.lastMessageAt = currentTick;
    room.messageCount++;

    // If sent by player, queue for all angel participants
    if (request.senderType === 'player') {
      for (const participantId of room.participants) {
        if (participantId !== request.senderId) {
          const pending = state.pendingMessages.get(participantId) || [];
          pending.push(message.id);
          state.pendingMessages.set(participantId, pending);
        }
      }
    }

    return message;
  }

  /**
   * Get messages for a chat
   */
  static getMessages(
    world: World,
    chatId: string,
    limit: number = 50
  ): ChatMessage[] {
    const state = AngelPhoneSystem.getState(world);
    const messages = state.messages.get(chatId) || [];
    return messages.slice(-limit);
  }

  /**
   * Get unread message count for an angel
   */
  static getUnreadCount(world: World, angelId: string): number {
    const state = AngelPhoneSystem.getState(world);
    const pending = state.pendingMessages.get(angelId) || [];
    return pending.length;
  }

  /**
   * Mark messages as read by an angel
   */
  static markAsRead(world: World, angelId: string, messageIds: string[]): void {
    const state = AngelPhoneSystem.getState(world);

    for (const [chatId, messages] of state.messages) {
      for (const message of messages) {
        if (messageIds.includes(message.id) && !message.readBy.includes(angelId)) {
          message.readBy.push(angelId);
        }
      }
    }

    // Clear from pending
    const pending = state.pendingMessages.get(angelId) || [];
    const remaining = pending.filter(id => !messageIds.includes(id));
    state.pendingMessages.set(angelId, remaining);
  }

  /**
   * Get all chat rooms an angel is part of
   */
  static getAngelChatRooms(world: World, angelId: string): ChatRoom[] {
    const state = AngelPhoneSystem.getState(world);
    const rooms: ChatRoom[] = [];

    for (const room of state.chatRooms.values()) {
      if (room.participants.includes(angelId)) {
        rooms.push(room);
      }
    }

    return rooms;
  }

  /**
   * Get pending messages for an angel to process
   */
  static getPendingMessages(world: World, angelId: string): ChatMessage[] {
    const state = AngelPhoneSystem.getState(world);
    const pendingIds = state.pendingMessages.get(angelId) || [];
    const messages: ChatMessage[] = [];

    for (const [, chatMessages] of state.messages) {
      for (const msg of chatMessages) {
        if (pendingIds.includes(msg.id)) {
          messages.push(msg);
        }
      }
    }

    return messages;
  }

  /**
   * System update - process phone checks for all angels
   */
  protected onUpdate(ctx: SystemContext): void {
    const world = ctx.world;
    const currentTick = ctx.tick;

    // Find all angel entities with messaging components
    const angelEntities = world.query()
      .with('angel')
      .with('angel_messaging')
      .executeEntities();

    for (const entity of angelEntities) {
      this.processAngelPhoneCheck(world, entity, currentTick);
    }
  }

  /**
   * Process phone check for a single angel
   */
  private processAngelPhoneCheck(
    world: World,
    entity: Entity,
    currentTick: number
  ): void {
    const messaging = entity.getComponent<AngelMessagingComponent>('angel_messaging');
    const angel = entity.getComponent<AngelComponent>('angel');

    if (!messaging || !angel) return;

    // Check if it's time to check the phone
    if (!messaging.shouldCheckPhone(currentTick)) {
      return;
    }

    // Mark phone as checked
    messaging.markPhoneChecked(currentTick);

    // Get pending messages
    const pendingMessages = AngelPhoneSystem.getPendingMessages(world, entity.id);

    if (pendingMessages.length === 0) {
      messaging.clearUnreadMessages();
      return;
    }

    // Mark all as read
    const messageIds = pendingMessages.map(m => m.id);
    AngelPhoneSystem.markAsRead(world, entity.id, messageIds);
    messaging.clearUnreadMessages();

    // TODO: Generate angel responses via LLM
    // This would integrate with AngelAIDecisionProcessor
    // For now, just acknowledge receipt
  }
}

/**
 * Helper to set up messaging for a newly created angel
 */
export function setupAngelMessaging(
  world: World,
  angelEntity: Entity,
  deityId: string,
  deityName: string,
  angelName: string,
  currentTick: number
): void {
  // Create or get group chat
  const groupChat = AngelPhoneSystem.createGroupChat(world, deityId, deityName, currentTick);

  // Create DM chat
  const dmChat = AngelPhoneSystem.createDMChat(
    world,
    deityId,
    angelEntity.id,
    angelName,
    currentTick
  );

  // Add angel to group chat
  AngelPhoneSystem.addAngelToGroupChat(world, deityId, angelEntity.id);

  // Add messaging component to angel
  const messaging = createAngelMessagingComponent({
    groupChatId: groupChat.id,
    dmChatId: dmChat.id,
    currentTick,
  });

  (angelEntity as EntityImpl).addComponent(messaging);
}

/**
 * Send a message from the player deity to angels
 */
export function sendDeityMessage(
  world: World,
  deityId: string,
  deityName: string,
  chatId: string,
  content: string,
  currentTick: number
): ChatMessage | null {
  return AngelPhoneSystem.sendMessage(world, {
    chatId,
    senderId: deityId,
    senderType: 'player',
    senderName: deityName,
    content,
  }, currentTick);
}

/**
 * Send a message from an angel
 */
export function sendAngelMessage(
  world: World,
  angelId: string,
  angelName: string,
  chatId: string,
  content: string,
  currentTick: number,
  replyToId?: string
): ChatMessage | null {
  return AngelPhoneSystem.sendMessage(world, {
    chatId,
    senderId: angelId,
    senderType: 'angel',
    senderName: angelName,
    content,
    replyToId,
  }, currentTick);
}
