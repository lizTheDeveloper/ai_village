import { describe, it, expect, beforeEach } from 'vitest';
import { World } from '../../World';
import { AISystem } from '../AISystem';
import { AgentComponent } from '../../components/AgentComponent';
import { CircadianComponent } from '../../components/CircadianComponent';

describe('AISystem - Sleep Decision Integration', () => {
  let world: World;
  let aiSystem: AISystem;
  let agent: any;

  beforeEach(() => {
    world = new World();
    aiSystem = new AISystem();

    agent = world.createEntity();
    agent.addComponent(AgentComponent, {
      name: 'Test Agent',
      position: { x: 0, y: 0 },
      needs: {
        hunger: 100,
        thirst: 100,
        temperature: 20,
        energy: 100,
        health: 100
      }
    });
    agent.addComponent(CircadianComponent, {});
  });

  describe('Sleep Priority in Decision Tree', () => {
    it('should prioritize critical needs over sleep', () => {
      const agentComp = agent.getComponent(AgentComponent);
      const circadian = agent.getComponent(CircadianComponent);

      agentComp.needs.health = 15; // Critical health
      circadian.sleepDrive = 90; // Very tired

      const behavior = aiSystem.decideBehavior(agent);

      expect(behavior).toBe('flee_danger');
    });

    it('should prioritize critical hunger over sleep', () => {
      const agentComp = agent.getComponent(AgentComponent);
      const circadian = agent.getComponent(CircadianComponent);

      agentComp.needs.hunger = 5;
      circadian.sleepDrive = 90;

      const behavior = aiSystem.decideBehavior(agent);

      expect(behavior).toBe('seek_food');
    });

    it('should prioritize critical thirst over sleep', () => {
      const agentComp = agent.getComponent(AgentComponent);
      const circadian = agent.getComponent(CircadianComponent);

      agentComp.needs.thirst = 5;
      circadian.sleepDrive = 90;

      const behavior = aiSystem.decideBehavior(agent);

      expect(behavior).toBe('seek_water');
    });

    it('should seek sleep when sleepDrive > 80', () => {
      const circadian = agent.getComponent(CircadianComponent);
      circadian.sleepDrive = 85;

      const behavior = aiSystem.decideBehavior(agent);

      expect(behavior).toBe('seek_sleep');
    });

    it('should seek sleep when energy < 15', () => {
      const agentComp = agent.getComponent(AgentComponent);
      agentComp.needs.energy = 10;

      const behavior = aiSystem.decideBehavior(agent);

      expect(behavior).toBe('seek_sleep');
    });

    it('should prioritize temperature extremes over moderate sleep need', () => {
      const agentComp = agent.getComponent(AgentComponent);
      const circadian = agent.getComponent(CircadianComponent);

      agentComp.temperature = { state: 'hypothermia' };
      circadian.sleepDrive = 65; // Moderate tiredness

      const behavior = aiSystem.decideBehavior(agent);

      expect(behavior).toBe('seek_shelter');
    });

    it('should seek sleep for moderate sleepDrive (60-80) if not busy', () => {
      const circadian = agent.getComponent(CircadianComponent);
      circadian.sleepDrive = 65;
      agent.currentTask = null; // Not doing anything

      const behavior = aiSystem.decideBehavior(agent);

      expect(behavior).toBe('seek_sleep');
    });

    it('should NOT interrupt current task for moderate sleep need', () => {
      const circadian = agent.getComponent(CircadianComponent);
      circadian.sleepDrive = 65;
      agent.currentTask = 'gathering'; // Busy

      const behavior = aiSystem.decideBehavior(agent);

      expect(behavior).not.toBe('seek_sleep');
    });
  });

  describe('Forced Sleep (Critical Exhaustion)', () => {
    it('should force sleep when both energy and sleepDrive are critical', () => {
      const agentComp = agent.getComponent(AgentComponent);
      const circadian = agent.getComponent(CircadianComponent);

      agentComp.needs.energy = 3;
      circadian.sleepDrive = 97;

      const behavior = aiSystem.decideBehavior(agent);

      expect(behavior).toBe('forced_sleep');
    });

    it('should immediately transition to sleeping state', () => {
      const agentComp = agent.getComponent(AgentComponent);
      const circadian = agent.getComponent(CircadianComponent);

      agentComp.needs.energy = 3;
      circadian.sleepDrive = 97;

      aiSystem.update(world, 1);

      expect(circadian.isSleeping).toBe(true);
    });

    it('should interrupt any current task for forced sleep', () => {
      const agentComp = agent.getComponent(AgentComponent);
      const circadian = agent.getComponent(CircadianComponent);

      agentComp.needs.energy = 3;
      circadian.sleepDrive = 97;
      agent.currentTask = 'building';

      const behavior = aiSystem.decideBehavior(agent);

      expect(behavior).toBe('forced_sleep');
      expect(agent.currentTask).toBeNull();
    });
  });

  describe('Behavior Weight Modifiers', () => {
    it('should increase sleep behavior weight as energy decreases', () => {
      const circadian = agent.getComponent(CircadianComponent);
      circadian.sleepDrive = 50; // Moderate

      // Test at different energy levels
      const agentComp = agent.getComponent(AgentComponent);

      agentComp.needs.energy = 100;
      const weight100 = aiSystem.getBehaviorWeight(agent, 'seek_sleep');

      agentComp.needs.energy = 50;
      const weight50 = aiSystem.getBehaviorWeight(agent, 'seek_sleep');

      agentComp.needs.energy = 20;
      const weight20 = aiSystem.getBehaviorWeight(agent, 'seek_sleep');

      expect(weight20).toBeGreaterThan(weight50);
      expect(weight50).toBeGreaterThan(weight100);
    });

    it('should increase sleep behavior weight as sleepDrive increases', () => {
      const agentComp = agent.getComponent(AgentComponent);
      const circadian = agent.getComponent(CircadianComponent);
      agentComp.needs.energy = 60; // Moderate energy

      circadian.sleepDrive = 40;
      const weight40 = aiSystem.getBehaviorWeight(agent, 'seek_sleep');

      circadian.sleepDrive = 70;
      const weight70 = aiSystem.getBehaviorWeight(agent, 'seek_sleep');

      circadian.sleepDrive = 90;
      const weight90 = aiSystem.getBehaviorWeight(agent, 'seek_sleep');

      expect(weight90).toBeGreaterThan(weight70);
      expect(weight70).toBeGreaterThan(weight40);
    });

    it('should reduce work behavior weight when fatigued', () => {
      const agentComp = agent.getComponent(AgentComponent);

      agentComp.needs.energy = 100;
      const workWeight100 = aiSystem.getBehaviorWeight(agent, 'gather_resources');

      agentComp.needs.energy = 30;
      const workWeight30 = aiSystem.getBehaviorWeight(agent, 'gather_resources');

      expect(workWeight30).toBeLessThan(workWeight100);
    });
  });

  describe('Sleep Location Preferences', () => {
    it('should prefer owned bed when deciding to sleep', () => {
      const circadian = agent.getComponent(CircadianComponent);
      circadian.sleepDrive = 85;

      const ownedBed = world.createEntity();
      ownedBed.type = 'bed';
      ownedBed.owner = agent;
      ownedBed.position = { x: 5, y: 5 };

      const targetLocation = aiSystem.getTargetSleepLocation(agent, world);

      expect(targetLocation).toBe(ownedBed);
    });

    it('should remember last sleep location if successful', () => {
      const circadian = agent.getComponent(CircadianComponent);
      const bed = world.createEntity();
      bed.type = 'bed';
      bed.position = { x: 5, y: 5 };

      circadian.lastSleepLocation = bed;
      circadian.sleepDrive = 85;

      const targetLocation = aiSystem.getTargetSleepLocation(agent, world);

      expect(targetLocation).toBe(bed);
    });

    it('should seek new location if last location is occupied', () => {
      const circadian = agent.getComponent(CircadianComponent);
      const bed = world.createEntity();
      bed.type = 'bed';
      bed.position = { x: 5, y: 5 };
      bed.occupied = true;

      circadian.lastSleepLocation = bed;
      circadian.sleepDrive = 85;

      const targetLocation = aiSystem.getTargetSleepLocation(agent, world);

      expect(targetLocation).not.toBe(bed);
    });
  });

  describe('Wake-Up Behavior Resumption', () => {
    it('should resume previous task after waking if still relevant', () => {
      const circadian = agent.getComponent(CircadianComponent);
      agent.previousTask = 'gather_resources';

      circadian.isSleeping = true;
      circadian.wake();

      aiSystem.update(world, 1);

      // Should attempt to resume gathering if conditions allow
      expect(agent.currentTask).toBeDefined();
    });

    it('should not resume task if critical needs arose during sleep', () => {
      const agentComp = agent.getComponent(AgentComponent);
      const circadian = agent.getComponent(CircadianComponent);

      agent.previousTask = 'building';
      circadian.isSleeping = true;

      agentComp.needs.hunger = 5; // Critical during sleep
      circadian.wake();

      const behavior = aiSystem.decideBehavior(agent);

      expect(behavior).toBe('seek_food'); // Not 'building'
    });
  });

  describe('Multi-Agent Sleep Competition', () => {
    it('should handle multiple agents seeking same bed', () => {
      const agent2 = world.createEntity();
      agent2.addComponent(AgentComponent, {
        name: 'Agent 2',
        position: { x: 1, y: 1 },
        needs: {
          hunger: 100,
          thirst: 100,
          temperature: 20,
          energy: 20,
          health: 100
        }
      });
      agent2.addComponent(CircadianComponent, {});

      const bed = world.createEntity();
      bed.type = 'bed';
      bed.position = { x: 5, y: 5 };

      const circadian1 = agent.getComponent(CircadianComponent);
      const circadian2 = agent2.getComponent(CircadianComponent);

      circadian1.sleepDrive = 85;
      circadian2.sleepDrive = 85;

      // Both try to sleep
      aiSystem.update(world, 1);

      // Only one should get the bed
      const sleepingAgents = [circadian1.isSleeping, circadian2.isSleeping]
        .filter(Boolean).length;

      expect(bed.occupied).toBe(true);
      expect(sleepingAgents).toBeGreaterThan(0);
    });

    it('should have second agent find alternative if first claims bed', () => {
      const agent2 = world.createEntity();
      agent2.addComponent(AgentComponent, {
        name: 'Agent 2',
        position: { x: 1, y: 1 },
        needs: { hunger: 100, thirst: 100, temperature: 20, energy: 20, health: 100 }
      });
      agent2.addComponent(CircadianComponent, {});

      const bed = world.createEntity();
      bed.type = 'bed';
      bed.position = { x: 5, y: 5 };

      const circadian1 = agent.getComponent(CircadianComponent);
      const circadian2 = agent2.getComponent(CircadianComponent);

      // Agent 1 claims bed first
      circadian1.sleepDrive = 85;
      circadian1.startSleeping(0, bed);
      bed.occupied = true;

      // Agent 2 tries to sleep
      circadian2.sleepDrive = 85;
      const location2 = aiSystem.getTargetSleepLocation(agent2, world);

      expect(location2).not.toBe(bed); // Should find alternative
    });
  });

  describe('Error Handling', () => {
    it('should throw when agent lacks CircadianComponent', () => {
      const badAgent = world.createEntity();
      badAgent.addComponent(AgentComponent, {
        name: 'Bad Agent',
        position: { x: 0, y: 0 },
        needs: { hunger: 100, thirst: 100, temperature: 20, health: 100 }
      });

      expect(() => aiSystem.decideBehavior(badAgent)).toThrow('CircadianComponent');
    });

    it('should throw when energy field is missing from needs', () => {
      const badAgent = world.createEntity();
      badAgent.addComponent(AgentComponent, {
        name: 'Bad Agent',
        position: { x: 0, y: 0 },
        needs: { hunger: 100, thirst: 100, temperature: 20, health: 100 }
        // Missing energy field
      });
      badAgent.addComponent(CircadianComponent, {});

      expect(() => aiSystem.decideBehavior(badAgent)).toThrow('energy');
    });
  });
});
