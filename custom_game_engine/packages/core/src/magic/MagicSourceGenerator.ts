/**
 * MagicSourceGenerator - Generate magic sources and resource pools
 *
 * This module generates magic sources (where power comes from) and their
 * associated resource pools (mana, divine favor, breath, etc.) for different
 * magical paradigms.
 */

import type {
  MagicSource,
  MagicSourceType,
  Detectability,
} from './MagicParadigm.js';

// ============================================================================
// Resource Pool Types
// ============================================================================

/** A magical resource pool (mana, favor, breath, etc.) */
export interface MagicResourcePool {
  /** Unique ID for this pool */
  id: string;

  /** Display name */
  name: string;

  /** What paradigm this pool belongs to */
  paradigmId: string;

  /** Current amount */
  current: number;

  /** Maximum capacity */
  maximum: number;

  /** Base regeneration rate per second */
  regenRate: number;

  /** Whether regeneration happens automatically */
  autoRegen: boolean;

  /** Conditions required for regeneration */
  regenConditions?: {
    requiresRest?: boolean;
    requiresSleep?: boolean;
    requiresPrayer?: boolean;
    requiresRitual?: boolean;
  };

  /** Visual color for UI display */
  color?: string;

  /** Icon/symbol for UI display */
  icon?: string;
}

// ============================================================================
// Generation Configuration
// ============================================================================

/** Configuration for generating a magic source */
export interface MagicSourceGenerationConfig {
  /** Source type to generate */
  sourceType: MagicSourceType;

  /** Optional custom name */
  customName?: string;

  /** Base pool size (if internal) */
  basePoolSize?: number;

  /** Regeneration rate multiplier */
  regenMultiplier?: number;

  /** Whether the source should be storable */
  storable?: boolean;

  /** Whether the source should be transferable */
  transferable?: boolean;

  /** Whether the source can be stolen */
  stealable?: boolean;

  /** How detectable magic use is */
  detectability?: Detectability;
}

// ============================================================================
// Source Templates by Type
// ============================================================================

/** Default configurations for each source type */
const SOURCE_TEMPLATES: Record<MagicSourceType, Partial<MagicSource>> = {
  internal: {
    name: 'Personal Mana',
    regeneration: 'passive',
    regenRate: 1.0,
    storable: true,
    transferable: false,
    stealable: true,
    detectability: 'subtle',
    description: 'Internal magical energy that regenerates naturally',
  },

  ambient: {
    name: 'Ambient Energy',
    regeneration: 'passive',
    regenRate: 0.5,
    storable: true,
    transferable: true,
    stealable: false,
    detectability: 'obvious',
    description: 'Environmental magical energy from ley lines and natural forces',
  },

  divine: {
    name: 'Divine Favor',
    regeneration: 'prayer',
    regenRate: 0.1,
    storable: false,
    transferable: false,
    stealable: false,
    detectability: 'beacon',
    description: 'Power granted by deities in response to worship and devotion',
  },

  material: {
    name: 'Material Components',
    regeneration: 'consumption',
    regenRate: 0,
    storable: true,
    transferable: true,
    stealable: true,
    detectability: 'obvious',
    description: 'Magical energy stored in physical components and reagents',
  },

  emotional: {
    name: 'Emotional Energy',
    regeneration: 'passive',
    regenRate: 0.8,
    storable: true,
    transferable: true,
    stealable: true,
    detectability: 'subtle',
    description: 'Power drawn from intense emotions and feelings',
  },

  social: {
    name: 'Collective Faith',
    regeneration: 'prayer',
    regenRate: 0.2,
    storable: false,
    transferable: false,
    stealable: false,
    detectability: 'beacon',
    description: 'Power generated by worshippers and believers',
  },

  knowledge: {
    name: 'Secret Knowledge',
    regeneration: 'none',
    regenRate: 0,
    storable: true,
    transferable: true,
    stealable: true,
    detectability: 'undetectable',
    description: 'Power from knowing true names and hidden secrets',
  },

  temporal: {
    name: 'Temporal Energy',
    regeneration: 'ritual',
    regenRate: 0.3,
    storable: false,
    transferable: false,
    stealable: false,
    detectability: 'beacon',
    description: 'Energy drawn from the flow of time itself',
  },

  void: {
    name: 'Void Energy',
    regeneration: 'none',
    regenRate: 0,
    storable: true,
    transferable: false,
    stealable: false,
    detectability: 'beacon',
    description: 'Power from emptiness and anti-reality',
  },

  ancestral: {
    name: 'Ancestral Power',
    regeneration: 'ritual',
    regenRate: 0.2,
    storable: false,
    transferable: false,
    stealable: false,
    detectability: 'subtle',
    description: 'Power channeled from spirits of the dead',
  },

  bloodline: {
    name: 'Bloodline Heritage',
    regeneration: 'rest',
    regenRate: 0.5,
    storable: false,
    transferable: false,
    stealable: false,
    detectability: 'subtle',
    description: 'Inherited magical power flowing through your lineage',
  },
};

// ============================================================================
// Pool Size Calculation
// ============================================================================

/**
 * Calculate base pool size based on source type and character level.
 */
export function calculateBasePoolSize(
  sourceType: MagicSourceType,
  level: number = 1,
  multiplier: number = 1.0
): number {
  // Base pool sizes by source type
  const baseSizes: Record<MagicSourceType, number> = {
    internal: 100,      // Standard mana pool
    ambient: 50,        // Smaller, relies on environment
    divine: 200,        // Large but slow regen
    material: 0,        // No pool, uses actual components
    emotional: 75,      // Medium, fluctuates
    social: 150,        // Large, powered by followers
    knowledge: 0,       // No pool, discrete secrets known
    temporal: 80,       // Medium, hard to access
    void: 60,           // Small but powerful
    ancestral: 100,     // Standard, ritual-based
    bloodline: 120,     // Slightly above standard
  };

  const base = baseSizes[sourceType];

  // Scale with level (10% per level)
  const levelBonus = base * (level - 1) * 0.1;

  return Math.floor((base + levelBonus) * multiplier);
}

/**
 * Calculate regeneration rate based on source type and conditions.
 */
export function calculateRegenRate(
  sourceType: MagicSourceType,
  baseRate?: number,
  multiplier: number = 1.0
): number {
  const template = SOURCE_TEMPLATES[sourceType];
  const rate = baseRate ?? template.regenRate ?? 0;

  return rate * multiplier;
}

// ============================================================================
// Generator Functions
// ============================================================================

/**
 * Generate a magic source definition.
 */
export function generateMagicSource(
  paradigmId: string,
  config: MagicSourceGenerationConfig
): MagicSource {
  const template = SOURCE_TEMPLATES[config.sourceType];
  const sourceId = `${paradigmId}-source`;

  return {
    id: sourceId,
    name: config.customName ?? template.name ?? 'Unknown Source',
    type: config.sourceType,
    regeneration: template.regeneration ?? 'passive',
    regenRate: calculateRegenRate(
      config.sourceType,
      template.regenRate,
      config.regenMultiplier
    ),
    storable: config.storable ?? template.storable ?? false,
    transferable: config.transferable ?? template.transferable ?? false,
    stealable: config.stealable ?? template.stealable ?? false,
    detectability: config.detectability ?? template.detectability ?? 'obvious',
    description: template.description,
  };
}

/**
 * Generate a resource pool for a magic source.
 */
export function generateResourcePool(
  paradigmId: string,
  source: MagicSource,
  level: number = 1,
  sizeMultiplier: number = 1.0
): MagicResourcePool | null {
  // Some sources don't have pools (material components, knowledge)
  if (source.type === 'material' || source.type === 'knowledge') {
    return null;
  }

  const poolSize = calculateBasePoolSize(source.type, level, sizeMultiplier);

  // Determine regen conditions based on regeneration type
  const regenConditions: MagicResourcePool['regenConditions'] = {};
  let autoRegen = true;

  switch (source.regeneration) {
    case 'rest':
      regenConditions.requiresRest = true;
      autoRegen = false;
      break;
    case 'sleep':
      regenConditions.requiresSleep = true;
      autoRegen = false;
      break;
    case 'prayer':
      regenConditions.requiresPrayer = true;
      autoRegen = false;
      break;
    case 'ritual':
      regenConditions.requiresRitual = true;
      autoRegen = false;
      break;
    case 'consumption':
      autoRegen = false;
      break;
    case 'none':
      autoRegen = false;
      break;
    case 'passive':
    default:
      autoRegen = true;
      break;
  }

  // UI colors by source type
  const colors: Record<MagicSourceType, string> = {
    internal: '#4488ff',      // Blue
    ambient: '#88ff88',       // Green
    divine: '#ffdd44',        // Gold
    material: '#ff8844',      // Orange
    emotional: '#ff44ff',     // Magenta
    social: '#44ddff',        // Cyan
    knowledge: '#cc44ff',     // Purple
    temporal: '#44ffff',      // Aqua
    void: '#222222',          // Dark gray
    ancestral: '#888888',     // Gray
    bloodline: '#ff4444',     // Red
  };

  // UI icons by source type
  const icons: Record<MagicSourceType, string> = {
    internal: 'âœ¨',
    ambient: 'ðŸŒ¿',
    divine: 'â˜€ï¸',
    material: 'ðŸ§ª',
    emotional: 'ðŸ’“',
    social: 'ðŸ‘¥',
    knowledge: 'ðŸ“œ',
    temporal: 'â³',
    void: 'ðŸŒ‘',
    ancestral: 'ðŸ‘»',
    bloodline: 'ðŸ©¸',
  };

  return {
    id: `${paradigmId}-pool`,
    name: source.name,
    paradigmId,
    current: poolSize, // Start at full
    maximum: poolSize,
    regenRate: source.regenRate ?? 0,
    autoRegen,
    regenConditions: Object.keys(regenConditions).length > 0 ? regenConditions : undefined,
    color: colors[source.type],
    icon: icons[source.type],
  };
}

/**
 * Generate magic source and pool for a paradigm.
 */
export function generateParadigmSource(
  paradigmId: string,
  sourceType: MagicSourceType,
  level: number = 1,
  config?: Partial<MagicSourceGenerationConfig>
): { source: MagicSource; pool: MagicResourcePool | null } {
  const fullConfig: MagicSourceGenerationConfig = {
    sourceType,
    ...config,
  };

  const source = generateMagicSource(paradigmId, fullConfig);
  const pool = generateResourcePool(paradigmId, source, level, config?.basePoolSize);

  return { source, pool };
}

// ============================================================================
// Paradigm-Specific Generators - Core Paradigms
// ============================================================================

/**
 * Generate source for Academic paradigm (mana-based).
 */
export function generateAcademicSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('academic', 'internal', level, {
    customName: 'Mana Pool',
    storable: true,
    transferable: false,
    stealable: true,
    detectability: 'subtle',
  });
}

/**
 * Generate source for Divine paradigm (favor-based).
 */
export function generateDivineSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('divine', 'divine', level, {
    customName: 'Divine Favor',
    storable: false,
    transferable: false,
    detectability: 'beacon',
  });
}

/**
 * Generate source for Blood paradigm (health-based).
 */
export function generateBloodSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('blood', 'internal', level, {
    customName: 'Vitality',
    storable: true,
    transferable: true,
    stealable: true,
    detectability: 'obvious',
  });
}

/**
 * Generate source for Breath paradigm (breath-based).
 */
export function generateBreathSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('breath', 'internal', level, {
    customName: 'Breath',
    storable: true,
    transferable: true,
    stealable: false,
    detectability: 'subtle',
    regenMultiplier: 0.01, // Very slow natural regen
  });
}

/**
 * Generate source for Emotional paradigm (emotion-based).
 */
export function generateEmotionalSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('emotional', 'emotional', level, {
    customName: 'Emotional Energy',
    storable: true,
    transferable: true,
    stealable: true,
  });
}

/**
 * Generate source for Pact paradigm (favor-based).
 */
export function generatePactSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('pact', 'divine', level, {
    customName: 'Patron Favor',
    storable: false,
    transferable: false,
    detectability: 'beacon',
  });
}

/**
 * Generate source for Name paradigm (knowledge-based).
 */
export function generateNameSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('name', 'knowledge', level, {
    customName: 'Known Names',
    storable: true,
    transferable: true,
  });
}

/**
 * Generate source for Rune paradigm (internal + material).
 */
export function generateRuneSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('rune', 'internal', level, {
    customName: 'Runic Power',
    storable: true,
    transferable: false,
    detectability: 'obvious',
  });
}

/**
 * Generate source for Allomancy paradigm (metal-based, no pool).
 */
export function generateAllomancySource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('allomancy', 'material', level, {
    customName: 'Metal Reserves',
    storable: true,
    transferable: false,
    stealable: false,
    detectability: 'subtle',
  });
}

/**
 * Generate source for Shinto paradigm (kami favor).
 */
export function generateShintoSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('shinto', 'ancestral', level, {
    customName: 'Kami Favor',
    storable: false,
    transferable: false,
    stealable: false,
    detectability: 'subtle',
    regenMultiplier: 1.5,
  });
}

/**
 * Generate source for Sympathy paradigm (alar strength).
 */
export function generateSympathySource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('sympathy', 'internal', level, {
    customName: 'Alar',
    storable: false,
    transferable: false,
    stealable: false,
    detectability: 'undetectable',
  });
}

/**
 * Generate source for Daemon paradigm (external soul bond).
 */
export function generateDaemonSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('daemon', 'internal', level, {
    customName: 'Soul Bond',
    storable: false,
    transferable: false,
    stealable: false,
    detectability: 'obvious',
    regenMultiplier: 2.0, // Strong bond = good regen
  });
}

/**
 * Generate source for Dream paradigm (lucidity).
 */
export function generateDreamSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('dream', 'internal', level, {
    customName: 'Lucidity',
    storable: true,
    transferable: true,
    stealable: true,
    detectability: 'undetectable',
    regenMultiplier: 0.1, // Only regens while dreaming
  });
}

/**
 * Generate source for Song paradigm (harmonic energy).
 */
export function generateSongSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('song', 'internal', level, {
    customName: 'Harmonic Energy',
    storable: true,
    transferable: true,
    stealable: false,
    detectability: 'obvious',
  });
}

// ============================================================================
// Paradigm-Specific Generators - Whimsical Paradigms
// ============================================================================

/**
 * Generate source for Talent paradigm (innate talent, no pool).
 */
export function generateTalentSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('talent', 'internal', level, {
    customName: 'Innate Talent',
    storable: false,
    transferable: false,
    stealable: false,
    detectability: 'subtle',
    regenMultiplier: 0, // Talent is always available, no regen needed
  });
}

/**
 * Generate source for Narrative paradigm (story power).
 */
export function generateNarrativeSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('narrative', 'social', level, {
    customName: 'Narrative Weight',
    storable: false,
    transferable: true,
    stealable: false,
    detectability: 'undetectable',
  });
}

/**
 * Generate source for Pun paradigm (wordplay energy).
 */
export function generatePunSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('pun', 'ambient', level, {
    customName: 'Punergy',
    storable: true,
    transferable: true,
    stealable: false,
    detectability: 'obvious',
    regenMultiplier: 0.1, // 0.05 base * 0.1 = slow regen
  });
}

/**
 * Generate source for Wild paradigm (chaotic magic).
 */
export function generateWildSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('wild', 'ambient', level, {
    customName: 'Chaotic Essence',
    storable: false,
    transferable: false,
    stealable: false,
    detectability: 'obvious',
    regenMultiplier: 0.2, // 0.5 * 0.2 = 0.1 regen
  });
}

// ============================================================================
// Null/Anti-Magic Paradigms
// ============================================================================

/**
 * Generate source for Null paradigm (no magic exists).
 */
export function generateNullSource(_level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  // Return a dummy source with no pool - magic doesn't exist
  const source: MagicSource = {
    id: 'null-source',
    name: 'Nonexistent',
    type: 'void',
    regeneration: 'none',
    regenRate: 0,
    storable: false,
    transferable: false,
    stealable: false,
    detectability: 'undetectable',
    description: 'Magic does not exist in this universe',
  };
  return { source, pool: null };
}

/**
 * Generate source for Dead paradigm (depleted magic).
 */
export function generateDeadSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('dead', 'ambient', level, {
    customName: 'Depleted Mana',
    storable: false,
    transferable: false,
    stealable: false,
    detectability: 'undetectable',
    regenMultiplier: 0, // No regen - magic is dead
  });
}

/**
 * Generate source for Anti paradigm (active anti-magic).
 */
export function generateAntiSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  const result = generateParadigmSource('anti', 'ambient', level, {
    customName: 'The Anti',
    storable: false,
    transferable: false,
    stealable: false,
    detectability: 'obvious',
    regenMultiplier: -0.2, // NEGATIVE REGEN - drains magic
  });

  // Override regen rate to be negative
  if (result.pool) {
    result.pool.regenRate = -0.1;
  }

  return result;
}

/**
 * Generate source for Inverted paradigm (backwards magic).
 */
export function generateInvertedSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('inverted', 'internal', level, {
    customName: 'Inverted Mana',
    storable: true,
    transferable: true,
    stealable: true,
    detectability: 'subtle',
    regenMultiplier: 0.01,
  });
}

/**
 * Generate source for Tech Supremacy paradigm (tech blocks magic).
 */
export function generateTechSupremacySource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('tech_supremacy', 'ambient', level, {
    customName: 'Residual Mana',
    storable: true,
    transferable: true,
    stealable: false,
    detectability: 'undetectable',
    regenMultiplier: 0, // No regen in tech zones
  });
}

/**
 * Generate source for Rational paradigm (physics prevents magic).
 */
export function generateRationalSource(_level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  // Return a dummy source with no pool - physics prevents magic
  const source: MagicSource = {
    id: 'rational-source',
    name: 'Impossible',
    type: 'void',
    regeneration: 'none',
    regenRate: 0,
    storable: false,
    transferable: false,
    stealable: false,
    detectability: 'undetectable',
    description: 'Magic is physically impossible',
  };
  return { source, pool: null };
}

/**
 * Generate source for Sealed paradigm (magic is sealed away).
 */
export function generateSealedSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('sealed', 'ambient', level, {
    customName: 'Sealed Power',
    storable: false,
    transferable: false,
    stealable: false,
    detectability: 'subtle',
    regenMultiplier: 0, // Cannot access sealed power
  });
}

/**
 * Generate source for Divine Prohibition paradigm (forbidden magic).
 */
export function generateDivineProhibitionSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('divine_prohibition', 'internal', level, {
    customName: 'Forbidden Power',
    storable: true,
    transferable: true,
    stealable: false,
    detectability: 'beacon', // Gods can see it!
    regenMultiplier: 0.01,
  });
}

/**
 * Generate source for Divine Monopoly paradigm (only gods can use magic).
 */
export function generateDivineMonopolySource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('divine_monopoly', 'divine', level, {
    customName: 'Divine Essence',
    storable: false,
    transferable: false,
    stealable: false,
    detectability: 'beacon',
  });
}

// ============================================================================
// Hybrid Paradigms
// ============================================================================

/**
 * Generate source for Theurgy paradigm (divine + academic fusion).
 */
export function generateTheurgySource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('theurgy', 'divine', level, {
    customName: 'Theurgic Power',
    storable: true,
    transferable: false,
    stealable: false,
    detectability: 'subtle',
    regenMultiplier: 0.15, // 0.1 * 0.15 = 0.015
  });
}

/**
 * Generate source for Hemomancy paradigm (blood + pact fusion).
 */
export function generateHemomancySource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('hemomancy', 'void', level, {
    customName: 'Hemomantic Power',
    storable: false,
    transferable: false,
    stealable: false,
    detectability: 'beacon',
    regenMultiplier: 0, // Consumption-based, not passive
  });
}

/**
 * Generate source for Namebreath paradigm (names + breath fusion).
 */
export function generateNamebreathSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('namebreath', 'knowledge', level, {
    customName: 'Living Word',
    storable: true,
    transferable: true,
    stealable: false,
    detectability: 'subtle',
  });
}

// ============================================================================
// Dimensional Paradigms
// ============================================================================

/**
 * Generate source for Dimension paradigm (spatial dimension magic).
 */
export function generateDimensionSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('dimension', 'ambient', level, {
    customName: 'Hyperspatial Energy',
    storable: true,
    transferable: true,
    stealable: false,
    detectability: 'subtle',
    regenMultiplier: 0.04, // 0.5 * 0.04 = 0.02
  });
}

/**
 * Generate source for Escalation paradigm (mundane actions escalate).
 */
export function generateEscalationSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('escalation', 'ambient', level, {
    customName: 'Mundane Energy',
    storable: false,
    transferable: false,
    stealable: false,
    detectability: 'undetectable',
    regenMultiplier: 0.2, // 0.5 * 0.2 = 0.1
  });
}

/**
 * Generate source for Corruption paradigm (power from lost identity).
 */
export function generateCorruptionSource(level: number = 1): {
  source: MagicSource;
  pool: MagicResourcePool | null;
} {
  return generateParadigmSource('corruption_crown', 'void', level, {
    customName: 'Corruption',
    storable: true,
    transferable: false,
    stealable: false,
    detectability: 'subtle',
    regenMultiplier: 0, // Special regen - grows as you corrupt
  });
}

// ============================================================================
// Pool Management Helpers
// ============================================================================

/**
 * Spend from a resource pool.
 */
export function spendFromPool(
  pool: MagicResourcePool,
  amount: number
): { success: boolean; remaining: number } {
  if (pool.current < amount) {
    return { success: false, remaining: pool.current };
  }

  pool.current -= amount;
  return { success: true, remaining: pool.current };
}

/**
 * Restore to a resource pool.
 */
export function restoreToPool(
  pool: MagicResourcePool,
  amount: number
): { newAmount: number; overflow: number } {
  const newAmount = Math.min(pool.maximum, pool.current + amount);
  const overflow = Math.max(0, (pool.current + amount) - pool.maximum);

  pool.current = newAmount;
  return { newAmount, overflow };
}

/**
 * Regenerate resource pool (call each tick/second).
 */
export function regeneratePool(
  pool: MagicResourcePool,
  deltaTime: number = 1.0,
  conditions?: {
    isResting?: boolean;
    isSleeping?: boolean;
    isPraying?: boolean;
    isPerformingRitual?: boolean;
  }
): number {
  // Check if regen conditions are met
  if (pool.regenConditions) {
    if (pool.regenConditions.requiresRest && !conditions?.isResting) return 0;
    if (pool.regenConditions.requiresSleep && !conditions?.isSleeping) return 0;
    if (pool.regenConditions.requiresPrayer && !conditions?.isPraying) return 0;
    if (pool.regenConditions.requiresRitual && !conditions?.isPerformingRitual) return 0;
  }

  // Only regen if auto-regen is enabled or conditions are met
  if (!pool.autoRegen && !conditions) return 0;

  const regenAmount = pool.regenRate * deltaTime;
  const result = restoreToPool(pool, regenAmount);

  return result.newAmount - (pool.current - regenAmount);
}

/**
 * Increase pool maximum (leveling up, etc.).
 */
export function increasePoolMaximum(pool: MagicResourcePool, increase: number): void {
  pool.maximum += increase;
  pool.current += increase; // Also increase current
}

/**
 * Get pool percentage (0-100).
 */
export function getPoolPercentage(pool: MagicResourcePool): number {
  if (pool.maximum === 0) return 100;
  return (pool.current / pool.maximum) * 100;
}
