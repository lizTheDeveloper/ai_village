/**
 * Magic System State Machine Exploits
 *
 * Tests for exploits based on state corruption and invalid transitions:
 * - Invalid state transitions
 * - Corrupted component states
 * - Impossible state combinations
 * - State machine bypasses
 * - Serialization/deserialization exploits
 * - Save state manipulation
 * - Component lifecycle exploits
 */

import { describe, it, expect } from 'vitest';
import {
  createMagicComponent,
  createMagicUserComponent,
  type MagicComponent,
  type ComposedSpell,
} from '../components/MagicComponent';
import {
  createSpiritualComponent,
  type SpiritualComponent,
} from '../components/SpiritualComponent';

describe('State Exploits - Invalid Transitions', () => {
  it('EXPLOIT: Skip from not-casting to spell-complete', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    // Valid states: idle -> casting -> complete -> idle
    // Current: idle
    expect(caster.casting).toBe(false);
    expect(caster.activeSpellId).toBeUndefined();

    // Jump directly to complete state
    caster.casting = false; // Not casting
    caster.activeSpellId = 'completed_spell'; // But has active spell!

    // Impossible state: not casting but has active spell
    const impossibleState = !caster.casting && caster.activeSpellId !== undefined;
    expect(impossibleState).toBe(true);

    // EXPLOIT: Set activeSpellId without casting
    // Triggers completion effects without paying costs
  });

  it('EXPLOIT: Cast while already casting (double-cast state)', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    const spell1: ComposedSpell = {
      id: 'spell1',
      name: 'Spell 1',
      technique: 'create',
      form: 'fire',
      source: 'arcane',
      manaCost: 40,
      castTime: 50,
      range: 10,
      duration: 0,
      effectId: 'damage',
    };

    // Start casting spell1
    caster.casting = true;
    caster.activeSpellId = spell1.id;

    // Without clearing first spell, start casting spell2
    const spell2: ComposedSpell = {
      id: 'spell2',
      name: 'Spell 2',
      technique: 'create',
      form: 'ice',
      source: 'arcane',
      manaCost: 40,
      castTime: 50,
      range: 10,
      duration: 0,
      effectId: 'freeze',
    };

    // Just change the active spell ID
    const previousSpell = caster.activeSpellId;
    caster.activeSpellId = spell2.id;

    expect(previousSpell).not.toBe(caster.activeSpellId);

    // EXPLOIT: Change active spell mid-cast
    // First spell's costs paid but second spell completes
  });

  it('EXPLOIT: Become magic user without initialization', () => {
    const nonMage = createMagicComponent();

    // Not a magic user
    expect(nonMage.magicUser).toBe(false);
    expect(nonMage.manaPools.length).toBe(0);

    // Just flip the flag
    nonMage.magicUser = true;

    // Now a magic user but with no mana pools!
    expect(nonMage.magicUser).toBe(true);
    expect(nonMage.manaPools.length).toBe(0);

    // EXPLOIT: Magic user with no mana = free spells?
  });

  it('EXPLOIT: Remove magic user flag while casting', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    const spell: ComposedSpell = {
      id: 'spell',
      name: 'Spell',
      technique: 'create',
      form: 'fire',
      source: 'arcane',
      manaCost: 50,
      castTime: 50,
      range: 10,
      duration: 0,
      effectId: 'damage',
    };

    // Start casting
    caster.casting = true;
    caster.activeSpellId = spell.id;

    // Remove magic user flag
    caster.magicUser = false;

    // Impossible state: non-mage is casting!
    const impossibleState = caster.casting && !caster.magicUser;
    expect(impossibleState).toBe(true);

    // EXPLOIT: Continue casting after losing magic ability
    // Effects trigger but no mana costs apply?
  });
});

describe('State Exploits - Corrupted Components', () => {
  it('EXPLOIT: Mana pool with no source', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    // Add pool with empty source
    caster.manaPools.push({
      source: '' as any, // Empty source!
      current: 1000,
      maximum: 1000,
      regenRate: 1.0,
      locked: 0,
    });

    // This pool might be ignored in validation
    // But used in mana calculations!
    expect(caster.manaPools.length).toBe(2);

    // EXPLOIT: Unnamed mana source as hidden extra mana pool
  });

  it('EXPLOIT: Paradigm ID that does not exist', () => {
    const caster = createMagicComponent();

    // Add paradigm IDs for paradigms that don't exist
    caster.knownParadigmIds = ['fake_paradigm', 'nonexistent', '__proto__'];

    expect(caster.knownParadigmIds.length).toBe(3);

    // If paradigm lookup returns null/undefined...
    // But code assumes paradigm exists...
    // Might cause bypass of paradigm restrictions!

    // EXPLOIT: Fake paradigms to avoid restrictions
  });

  it('EXPLOIT: Proficiency outside 0-100 range', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    caster.knownSpells.push({
      spellId: 'overpowered',
      proficiency: 1000, // Way over 100!
      timesCast: 0,
    });

    const spell = caster.knownSpells[0];
    expect(spell.proficiency).toBe(1000);

    // If proficiency multiplies power...
    const basePower = 100;
    const bonusFromProficiency = spell.proficiency / 100; // 10x!
    const finalPower = basePower * bonusFromProficiency;

    expect(finalPower).toBe(1000);

    // EXPLOIT: Uncapped proficiency for 10x power
  });

  it('EXPLOIT: Negative times cast for instant mastery', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    caster.knownSpells.push({
      spellId: 'master_spell',
      proficiency: 100,
      timesCast: -1000, // Negative casts!
    });

    // If timesCast is used in calculations...
    // Negative might cause underflow or wrap around

    const spell = caster.knownSpells[0];
    expect(spell.timesCast).toBeLessThan(0);

    // EXPLOIT: Negative cast count might trigger special logic
  });

  it('EXPLOIT: Corruption above 1.0', () => {
    const caster = createMagicUserComponent('blood', 100, 'blood_magic');

    // Max corruption should be 1.0 (100%)
    // But set it higher
    caster.corruption = 5.0; // 500%!

    expect(caster.corruption).toBeGreaterThan(1.0);

    // If corruption affects stats multiplicatively...
    const baseDamage = 100;
    const corruptionBonus = caster.corruption * 2; // 10x!
    const finalDamage = baseDamage * corruptionBonus;

    expect(finalDamage).toBe(1000);

    // EXPLOIT: Over-corrupt for massive power bonus
  });

  it('EXPLOIT: Spiritual component with no deity', () => {
    const spiritual = createSpiritualComponent(0);

    // Spiritual component but no deity field!
    // Prayers to undefined deity...
    // Might grant power from the void?

    spiritual.faith = 1.0;

    expect(spiritual.faith).toBe(1.0);
    expect((spiritual as any).deityId).toBeUndefined();

    // EXPLOIT: Worship void for deity-less divine power
  });

  it('EXPLOIT: Multiple primary sources', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    // Add another pool
    caster.manaPools.push({
      source: 'divine',
      current: 100,
      maximum: 100,
      regenRate: 0.05,
      locked: 0,
    });

    // Set primary source to arcane
    caster.primarySource = 'arcane';

    // But also store 'divine' somewhere else
    // If systems check different fields...

    // EXPLOIT: Multiple primary sources for double benefits
  });
});

describe('State Exploits - Impossible Combinations', () => {
  it('EXPLOIT: Divine and Pact paradigms simultaneously', () => {
    const caster = createMagicComponent();

    // Divine and Pact are mutually exclusive
    // But just add both to known paradigms
    caster.knownParadigmIds = ['divine', 'pact'];

    expect(caster.knownParadigmIds).toContain('divine');
    expect(caster.knownParadigmIds).toContain('pact');

    // Should be impossible, but state allows it
    // EXPLOIT: Use divine and pact magic together
  });

  it('EXPLOIT: Locked mana exceeds total mana', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');
    const pool = caster.manaPools.find(p => p.source === 'arcane');

    if (pool) {
      pool.current = 50;
      pool.locked = 200; // More than exists!

      expect(pool.locked).toBeGreaterThan(pool.current);

      // Available mana: 50 - 200 = -150
      const available = pool.current - pool.locked;
      expect(available).toBe(-150);

      // EXPLOIT: Negative available mana might overflow
      // Or cause free casting
    }
  });

  it('EXPLOIT: Casting but activeSpellId is undefined', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    caster.casting = true;
    caster.activeSpellId = undefined;

    const impossibleState = caster.casting && !caster.activeSpellId;
    expect(impossibleState).toBe(true);

    // Casting nothing!
    // Might consume mana but produce no effects
    // Or produce effects with no costs?

    // EXPLOIT: Cast "undefined" spell
  });

  it('EXPLOIT: Knowledge of spell but not paradigm', () => {
    const caster = createMagicComponent();
    caster.magicUser = true;

    // Know a spell from blood magic
    caster.knownSpells.push({
      spellId: 'blood_spell',
      proficiency: 50,
      timesCast: 10,
    });

    // But don't know blood magic paradigm!
    caster.knownParadigmIds = ['academic'];

    expect(caster.knownParadigmIds).not.toContain('blood_magic');
    expect(caster.knownSpells.some(s => s.spellId === 'blood_spell')).toBe(true);

    // EXPLOIT: Cast paradigm spells without knowing paradigm
    // Bypass paradigm restrictions
  });

  it('EXPLOIT: Home paradigm not in known paradigms', () => {
    const caster = createMagicComponent();
    caster.magicUser = true;

    caster.homeParadigmId = 'blood_magic';
    caster.knownParadigmIds = ['academic', 'divine'];

    expect(caster.knownParadigmIds).not.toContain(caster.homeParadigmId);

    // Home paradigm you don't know!
    // Might get home paradigm bonuses
    // Without knowing how to use it

    // EXPLOIT: Set home to unknown paradigm for bonuses
  });
});

describe('State Exploits - Serialization', () => {
  it('EXPLOIT: Inject extra fields via JSON', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    // Serialize to JSON
    const json = JSON.stringify(caster);

    // Parse and modify
    const parsed = JSON.parse(json);

    // Inject extra field
    parsed.godMode = true;
    parsed.infiniteMana = true;
    parsed.allSpellsKnown = true;

    // Load back
    const loaded = parsed as MagicComponent;

    expect((loaded as any).godMode).toBe(true);

    // EXPLOIT: Add extra fields to save file
    // If systems check these fields...
  });

  it('EXPLOIT: NaN and Infinity in serialized data', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    // Set values to NaN/Infinity
    const pool = caster.manaPools[0];
    pool.current = NaN;
    pool.maximum = Infinity;
    pool.regenRate = -Infinity;

    // Serialize
    const json = JSON.stringify(caster);

    // NaN becomes null, Infinity becomes null
    expect(json).toContain('null');

    // On load, null might become 0
    const parsed = JSON.parse(json);

    // EXPLOIT: NaN/Infinity serialize to null
    // Load might give different values
  });

  it('EXPLOIT: Circular references in paradigm state', () => {
    const caster = createMagicComponent();

    // Create circular reference
    const state: any = {
      paradigmId: 'test',
    };
    state.self = state; // Points to itself!

    caster.paradigmState['test'] = state;

    // Try to serialize
    let error = null;
    try {
      JSON.stringify(caster);
    } catch (e) {
      error = e;
    }

    expect(error).not.toBeNull();

    // EXPLOIT: Circular refs crash serialization
    // Could prevent saving or cause state loss
  });

  it('EXPLOIT: Prototype pollution via deserialization', () => {
    const maliciousJSON = `{
      "magicUser": true,
      "__proto__": {
        "isAdmin": true,
        "godMode": true
      }
    }`;

    const parsed = JSON.parse(maliciousJSON);
    const component = parsed as MagicComponent;

    // Check if pollution worked
    const anyObj: any = {};
    const polluted = anyObj.isAdmin === true;

    // EXPLOIT: Pollute Object.prototype via save data
    // Affects all objects in game!
    expect(parsed).toBeDefined();
  });

  it('EXPLOIT: Type confusion via serialization', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    // Serialize
    const json = JSON.stringify(caster);

    // Modify types in JSON
    const modified = json
      .replace('"magicUser":true', '"magicUser":"yes"') // Boolean -> String
      .replace('"proficiency":0', '"proficiency":"max"'); // Number -> String

    // Parse back
    const loaded = JSON.parse(modified) as MagicComponent;

    // Type is wrong!
    expect(typeof (loaded as any).magicUser).toBe('string');

    // EXPLOIT: Type confusion from manual save editing
    // String "yes" might be truthy
    // String "max" might parse to NaN
  });
});

describe('State Exploits - Component Lifecycle', () => {
  it('EXPLOIT: Use component after deletion', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    // Store reference
    const pool = caster.manaPools[0];

    // "Delete" component (clear arrays)
    caster.manaPools = [];
    caster.knownSpells = [];
    caster.knownParadigmIds = [];

    // But reference still exists!
    expect(pool.current).toBe(100);

    // Modify through old reference
    pool.current = 9999;

    // If anything still references old pool...
    expect(pool.current).toBe(9999);

    // EXPLOIT: Dangling references to deleted components
  });

  it('EXPLOIT: Double initialization', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    // Already initialized with 1 mana pool
    expect(caster.manaPools.length).toBe(1);

    // Initialize again
    caster.manaPools.push({
      source: 'arcane',
      current: 100,
      maximum: 100,
      regenRate: 0.05,
      locked: 0,
    });

    // Now has 2 pools for same source!
    expect(caster.manaPools.length).toBe(2);

    // EXPLOIT: Double mana pools for same source
    // Double regeneration? Double capacity?
  });

  it('EXPLOIT: Copy component reference instead of state', () => {
    const caster1 = createMagicUserComponent('arcane', 100, 'academic');

    // "Copy" by reference
    const caster2 = caster1;

    // Modify caster2
    const pool = caster2.manaPools[0];
    pool.current = 50;

    // Caster1 is also modified!
    expect(caster1.manaPools[0].current).toBe(50);

    // EXPLOIT: Shared component state
    // One entity's actions affect another
  });

  it('EXPLOIT: Modify const component fields', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    // Even if component has const fields, JS allows modification
    (caster as any).type = 'different_type';
    (caster as any).readonly_field = 'modified';

    // EXPLOIT: Const/readonly not enforced at runtime
    // Can modify any field
  });
});

describe('State Exploits - Paradigm State', () => {
  it('EXPLOIT: Shared paradigm state between entities', () => {
    const caster1 = createMagicComponent();
    const caster2 = createMagicComponent();

    caster1.knownParadigmIds = ['academic'];
    caster2.knownParadigmIds = ['academic'];

    // Both use same paradigm
    // But do they share state?
    const state1 = { power: 100 };

    caster1.paradigmState['academic'] = state1;
    caster2.paradigmState['academic'] = state1; // Same object!

    // Modify via caster1
    state1.power = 200;

    // Caster2's state also changes
    const caster2State = caster2.paradigmState['academic'] as any;
    expect(caster2State.power).toBe(200);

    // EXPLOIT: Shared paradigm state objects
    // One caster's power affects another!
  });

  it('EXPLOIT: Paradigm state for unknown paradigm', () => {
    const caster = createMagicComponent();

    // Don't know blood magic
    caster.knownParadigmIds = ['academic'];

    // But set blood magic state anyway
    caster.paradigmState['blood_magic'] = {
      corruption: 0.5,
      bloodDebt: 100,
    };

    expect('blood_magic' in caster.paradigmState).toBe(true);
    expect(caster.knownParadigmIds).not.toContain('blood_magic');

    // EXPLOIT: Have paradigm state without knowing paradigm
    // Might grant passive bonuses
  });

  it('EXPLOIT: Paradigm state without map initialization', () => {
    const caster = createMagicComponent();

    // Clear the state map
    (caster as any).paradigmState = undefined;

    // Try to use paradigm
    caster.knownParadigmIds = ['academic'];

    // Access state (will crash if not checked)
    // EXPLOIT: Uninitialized paradigm state map
  });
});

describe('State Exploits - Faith and Spiritual', () => {
  it('EXPLOIT: Faith above 1.0 and below 0.0', () => {
    const spiritual = createSpiritualComponent(0.5);

    // Faith should be 0.0 to 1.0
    // But set it out of range
    spiritual.faith = 2.5;

    expect(spiritual.faith).toBeGreaterThan(1.0);

    // Later set negative
    spiritual.faith = -0.5;

    expect(spiritual.faith).toBeLessThan(0.0);

    // EXPLOIT: Uncapped faith for super-devotion or anti-faith
  });

  it('EXPLOIT: Crisis of faith while casting divine spell', () => {
    const caster = createMagicUserComponent('divine', 100, 'divine');
    const spiritual = createSpiritualComponent(0.5);

    const divineSpell: ComposedSpell = {
      id: 'divine_wrath',
      name: 'Divine Wrath',
      technique: 'destroy',
      form: 'body',
      source: 'divine',
      manaCost: 80,
      castTime: 50,
      range: 20,
      duration: 0,
      effectId: 'smite',
    };

    // Start casting
    caster.casting = true;
    caster.activeSpellId = divineSpell.id;

    // Mid-cast, enter crisis of faith
    spiritual.crisisOfFaith = true;

    // Does spell fail? Continue with penalty? No effect?
    const impossibleState = caster.casting && spiritual.crisisOfFaith;
    expect(impossibleState).toBe(true);

    // EXPLOIT: Start divine cast before crisis
    // Crisis happens mid-cast
    // Spell might complete despite crisis
  });

  it('EXPLOIT: Prayers with future timestamps', () => {
    const spiritual = createSpiritualComponent(0.5);

    const currentTime = 1000;

    // Prayer from the future!
    spiritual.prayers.push({
      id: 'future_prayer',
      timestamp: 9999, // Far future
      content: 'Future prayer',
      intensity: 1.0,
      answered: true,
      answerTimestamp: 10000,
    });

    // If age calculations use (current - timestamp)...
    const age = currentTime - 9999;
    expect(age).toBeLessThan(0); // Negative age!

    // EXPLOIT: Future-dated prayers break age calculations
  });

  it('EXPLOIT: Unbounded doubts array', () => {
    const spiritual = createSpiritualComponent(0.5);

    // Add millions of doubts
    for (let i = 0; i < 1_000_000; i++) {
      spiritual.doubts.push({
        id: `doubt_${i}`,
        timestamp: i,
        reason: 'Why?',
        severity: 0.1,
        resolved: false,
      });
    }

    expect(spiritual.doubts.length).toBe(1_000_000);

    // Each doubt reduces faith
    const totalFaithLoss = spiritual.doubts.length * 0.0001;
    expect(totalFaithLoss).toBe(100);

    // EXPLOIT: Spam doubts to destroy faith
    // No limit on doubt accumulation
  });
});
