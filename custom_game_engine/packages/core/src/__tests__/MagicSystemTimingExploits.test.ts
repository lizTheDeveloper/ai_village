/**
 * Magic System Timing and Race Condition Exploits
 *
 * Tests for exploits based on timing, ordering, and concurrency:
 * - Simultaneous spell casting
 * - Interrupt-based exploits
 * - Cooldown manipulation
 * - State corruption from concurrent access
 * - Order-dependent exploits
 * - Frame-perfect timing windows
 * - Queue manipulation
 * - Tick-based exploits
 */

import { describe, it, expect } from 'vitest';
import {
  createMagicComponent,
  createMagicUserComponent,
  getMana,
  type ComposedSpell,
} from '../components/MagicComponent';
import {
  createSpiritualComponent,
  recordPrayer,
} from '../components/SpiritualComponent';

describe('Timing Exploits - Simultaneous Casting', () => {
  it('EXPLOIT: Cast two spells before mana check updates', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    const expensiveSpell: ComposedSpell = {
      id: 'expensive',
      name: 'Expensive',
      technique: 'create',
      form: 'fire',
      source: 'arcane',
      manaCost: 60,
      castTime: 50,
      range: 20,
      duration: 0,
      effectId: 'damage',
    };

    // Current mana: 100
    const initialMana = getMana(caster, 'arcane');
    expect(initialMana).toBe(100);

    // Start cast 1 (doesn't deduct mana yet)
    caster.casting = true;
    caster.activeSpellId = expensiveSpell.id;

    // Start cast 2 before cast 1 completes!
    // If mana check happens before deduction...
    const canCast2 = getMana(caster, 'arcane') >= expensiveSpell.manaCost;
    expect(canCast2).toBe(true); // Still shows 100 mana!

    // EXPLOIT: Start both casts, spend 120 mana with only 100 available
  });

  it('EXPLOIT: Chain cast during cooldown window', () => {
    const caster = createMagicUserComponent('arcane', 200, 'academic');

    const spell: ComposedSpell = {
      id: 'fireball',
      name: 'Fireball',
      technique: 'create',
      form: 'fire',
      source: 'arcane',
      manaCost: 30,
      castTime: 20,
      range: 30,
      duration: 0,
      effectId: 'damage',
    };

    // Assume cooldown: 100 ticks
    let cooldownRemaining = 100;
    let tick = 0;

    // Cast at tick 0
    tick = 0;
    cooldownRemaining = 100;

    // Try to cast at tick 99 (1 tick before cooldown ends)
    tick = 99;
    cooldownRemaining = 1;

    // If cooldown check is >= instead of >
    const canCastDuring = cooldownRemaining >= 1;
    expect(canCastDuring).toBe(true);

    // EXPLOIT: Cast during last tick of cooldown
    // Effective cooldown becomes 99 instead of 100
  });

  it('EXPLOIT: Interrupt spell to refund mana but keep effects', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    const sustainedSpell: ComposedSpell = {
      id: 'shield',
      name: 'Shield',
      technique: 'protect',
      form: 'body',
      source: 'arcane',
      manaCost: 50,
      castTime: 10,
      range: 0,
      duration: -1, // Sustained
      effectId: 'shield',
    };

    // Start casting
    caster.casting = true;
    caster.activeSpellId = sustainedSpell.id;

    // Mana is locked
    const pool = caster.manaPools.find(p => p.source === 'arcane');
    if (pool) {
      pool.locked = sustainedSpell.manaCost;
    }

    // Wait 9 ticks (1 tick before completion)
    const ticksWaited = 9;
    expect(ticksWaited).toBe(sustainedSpell.castTime - 1);

    // Cancel spell
    caster.casting = false;
    caster.activeSpellId = undefined;

    // If effect already applied but mana not deducted...
    // EXPLOIT: Get shield effect but cancel to refund mana
  });

  it('EXPLOIT: Cast during paradigm switch window', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');
    caster.knownParadigmIds = ['academic', 'blood_magic'];

    // Start as Academic
    caster.homeParadigmId = 'academic';

    const academicSpell: ComposedSpell = {
      id: 'transmute',
      name: 'Transmute',
      technique: 'transform',
      form: 'matter',
      source: 'arcane',
      manaCost: 40,
      castTime: 30,
      range: 5,
      duration: 0,
      effectId: 'lead_to_gold',
    };

    // Start casting
    caster.casting = true;
    caster.activeSpellId = academicSpell.id;

    // Switch paradigm mid-cast!
    caster.homeParadigmId = 'blood_magic';

    // If paradigm rules check happens at start but cost check at end...
    // Academic spell started (follows Conservation law)
    // But finishes under Blood magic (no Conservation law!)

    // EXPLOIT: Bypass paradigm restrictions by switching mid-cast
  });
});

describe('Timing Exploits - Cooldown Manipulation', () => {
  it('EXPLOIT: Reset cooldown by switching paradigms', () => {
    const caster = createMagicUserComponent('arcane', 200, 'academic');
    caster.knownParadigmIds = ['academic', 'rune'];

    // Cast spell, enter cooldown
    let lastCastTick = 0;
    let currentTick = 0;
    const cooldownDuration = 100;

    // At tick 50, cooldown is still active
    currentTick = 50;
    let cooldownRemaining = cooldownDuration - (currentTick - lastCastTick);
    expect(cooldownRemaining).toBe(50);

    // Switch paradigm
    caster.homeParadigmId = 'rune';

    // If cooldown is tracked per-spell-id but not per-paradigm...
    // Cooldown resets!
    lastCastTick = 0; // Reset

    // EXPLOIT: Switch paradigms to reset cooldowns
  });

  it('EXPLOIT: Stack cooldown reduction to go negative', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    // Base cooldown: 100 ticks
    let cooldown = 100;

    // Item 1: -20% cooldown
    cooldown *= 0.8; // 80

    // Item 2: -20% cooldown
    cooldown *= 0.8; // 64

    // Item 3: -20% cooldown
    cooldown *= 0.8; // 51.2

    // Item 4: -20% cooldown
    cooldown *= 0.8; // 40.96

    // Item 5: -20% cooldown
    cooldown *= 0.8; // 32.768

    expect(cooldown).toBeLessThan(33);

    // With 10 items of -20% each:
    let extremeCooldown = 100;
    for (let i = 0; i < 10; i++) {
      extremeCooldown *= 0.8;
    }

    // 100 * (0.8^10) = 10.74 ticks
    expect(extremeCooldown).toBeLessThan(11);

    // EXPLOIT: Stack cooldown reduction to near-zero cooldowns
  });

  it('EXPLOIT: Negative cooldown = immediate cast + gain ticks', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    // Base cooldown: 10 ticks
    let cooldown = 10;

    // Cooldown reduction: -15 ticks (from items/buffs)
    const reduction = 15;
    cooldown -= reduction;

    expect(cooldown).toBe(-5);

    // If negative cooldown adds to available casts...
    const extraCasts = Math.abs(cooldown);
    expect(extraCasts).toBe(5);

    // EXPLOIT: Negative cooldown = cast spell 5 extra times instantly!
  });

  it('EXPLOIT: Cast during time stop to skip cooldowns', () => {
    const caster = createMagicUserComponent('arcane', 200, 'academic');

    // Cast Time Stop spell
    const timeStopActive = true;

    // During time stop, game time doesn't advance
    let gameTick = 1000;

    // Cast spell at tick 1000
    const castTick = gameTick;
    const cooldownEnds = castTick + 100;

    // Time is stopped, tick doesn't advance
    gameTick = 1000; // Still 1000

    // But cast another spell
    const canCast = gameTick >= cooldownEnds; // false, but...

    // If spell queuing ignores time stop...
    expect(timeStopActive).toBe(true);

    // EXPLOIT: Queue unlimited spells during time stop
    // All execute when time resumes, no cooldowns!
  });
});

describe('Timing Exploits - Mana Regeneration', () => {
  it('EXPLOIT: Regenerate mana during cast time', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');
    const pool = caster.manaPools.find(p => p.source === 'arcane');

    if (pool) {
      pool.current = 50;
      pool.maximum = 100;
      pool.regenRate = 0.1; // 10% per tick = 10 mana per tick

      const expensiveSpell: ComposedSpell = {
        id: 'expensive',
        name: 'Expensive',
        technique: 'create',
        form: 'fire',
        source: 'arcane',
        manaCost: 60,
        castTime: 20, // Long cast time
        range: 20,
        duration: 0,
        effectId: 'damage',
      };

      // Can't cast: need 60, have 50
      expect(pool.current).toBeLessThan(expensiveSpell.manaCost);

      // But start casting anyway
      caster.casting = true;

      // During 20 tick cast time, regenerate:
      // 10 mana/tick * 20 ticks = 200 mana!
      const regenDuringCast = pool.regenRate * pool.maximum * expensiveSpell.castTime;
      expect(regenDuringCast).toBe(200);

      // Final mana: 50 + 200 = 250 (capped at 100)
      pool.current = Math.min(pool.maximum, pool.current + regenDuringCast);
      expect(pool.current).toBe(100);

      // EXPLOIT: Start casting when low on mana
      // Regen during cast time to pay for it!
    }
  });

  it('EXPLOIT: Switch mana source mid-cast for double regeneration', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    // Add second mana pool
    caster.manaPools.push({
      source: 'divine',
      current: 100,
      maximum: 100,
      regenRate: 0.05,
      locked: 0,
    });

    const spell: ComposedSpell = {
      id: 'hybrid',
      name: 'Hybrid',
      technique: 'create',
      form: 'fire',
      source: 'arcane',
      manaCost: 80,
      castTime: 50,
      range: 20,
      duration: 0,
      effectId: 'damage',
    };

    // Start casting with arcane
    caster.primarySource = 'arcane';
    caster.casting = true;

    // Arcane regenerates during cast
    const arcanePool = caster.manaPools.find(p => p.source === 'arcane');
    if (arcanePool) {
      const arcaneRegen = arcanePool.regenRate * arcanePool.maximum * spell.castTime;
      expect(arcaneRegen).toBeGreaterThan(0);
    }

    // Switch to divine mid-cast
    caster.primarySource = 'divine';

    // Divine also regenerates!
    const divinePool = caster.manaPools.find(p => p.source === 'divine');
    if (divinePool) {
      const divineRegen = divinePool.regenRate * divinePool.maximum * spell.castTime;
      expect(divineRegen).toBeGreaterThan(0);
    }

    // EXPLOIT: Switch sources to regenerate both pools during one cast!
  });

  it('EXPLOIT: Overflow mana regeneration to create mana', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');
    const pool = caster.manaPools.find(p => p.source === 'arcane');

    if (pool) {
      pool.current = 100;
      pool.maximum = 100;
      pool.regenRate = 0.1;

      // Increase maximum while at full
      pool.maximum = 200;

      // Still at 100/200
      expect(pool.current).toBe(100);

      // Regenerate
      const regen = pool.regenRate * pool.maximum; // 0.1 * 200 = 20
      pool.current += regen;

      expect(pool.current).toBe(120);

      // EXPLOIT: Increase max while at full, then regen from new max
      // Creates mana from nothing!
    }
  });

  it('EXPLOIT: Locked mana regenerates separately', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');
    const pool = caster.manaPools.find(p => p.source === 'arcane');

    if (pool) {
      pool.current = 100;
      pool.maximum = 100;
      pool.locked = 50; // Sustained spell
      pool.regenRate = 0.1;

      // Available mana: 100 - 50 = 50
      const available = pool.current - pool.locked;
      expect(available).toBe(50);

      // Spend 40 mana
      pool.current -= 40;

      // Current: 60, Locked: 50, Available: 10
      expect(pool.current).toBe(60);

      // Regenerate: 0.1 * 100 = 10
      pool.current += pool.regenRate * pool.maximum;

      // Current: 70, Locked: 50, Available: 20
      expect(pool.current - pool.locked).toBe(20);

      // But what if locked also regenerates?
      // EXPLOIT: Locked mana regenerates, effectively doubling regen rate
    }
  });
});

describe('Timing Exploits - Effect Duration', () => {
  it('EXPLOIT: Extend duration by refreshing before expiry', () => {
    const caster = createMagicUserComponent('arcane', 200, 'academic');

    const buffSpell: ComposedSpell = {
      id: 'buff',
      name: 'Buff',
      technique: 'enhance',
      form: 'body',
      source: 'arcane',
      manaCost: 30,
      castTime: 5,
      range: 0,
      duration: 100,
      effectId: 'strength_buff',
    };

    // Cast at tick 0
    let currentTick = 0;
    let buffExpires = currentTick + buffSpell.duration; // 100

    // Wait until tick 95
    currentTick = 95;

    // 5 ticks remaining
    const timeLeft = buffExpires - currentTick;
    expect(timeLeft).toBe(5);

    // Recast the buff
    buffExpires = currentTick + buffSpell.duration; // 195

    // Total buff duration: 195 ticks (95 + 100)
    // If buffs should have been 100, got 195 instead!

    // EXPLOIT: Refresh buffs before expiry to extend total duration
    // Never let buff fall off, maintain permanently for 30 mana/100 ticks
  });

  it('EXPLOIT: Stack duration by casting same spell multiple times', () => {
    const caster = createMagicUserComponent('arcane', 300, 'academic');

    const dotSpell: ComposedSpell = {
      id: 'poison',
      name: 'Poison',
      technique: 'destroy',
      form: 'body',
      source: 'arcane',
      manaCost: 20,
      castTime: 5,
      range: 10,
      duration: 50,
      effectId: 'poison_dot',
    };

    // If durations stack instead of refresh...
    const castCount = 5;
    let totalDuration = 0;

    for (let i = 0; i < castCount; i++) {
      totalDuration += dotSpell.duration;
    }

    // 50 * 5 = 250 ticks of poison!
    expect(totalDuration).toBe(250);

    // Damage per tick: 10
    // Total damage: 10 * 250 = 2500
    const damagePerTick = 10;
    const totalDamage = damagePerTick * totalDuration;
    expect(totalDamage).toBe(2500);

    // EXPLOIT: Stack same DoT spell to multiply damage
  });

  it('EXPLOIT: Negative duration = instant expiry + trigger', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    const trapSpell: ComposedSpell = {
      id: 'trap',
      name: 'Trap',
      technique: 'create',
      form: 'matter',
      source: 'arcane',
      manaCost: 40,
      castTime: 20,
      range: 10,
      duration: -1, // Sustained or instant?
      effectId: 'trap',
    };

    // If -1 means sustained, costs mana continuously
    // If -1 means instant, triggers immediately
    // But what if we set duration to -100?

    const negativeDuration = -100;

    // If expiry trigger fires when duration <= 0...
    const shouldTrigger = negativeDuration <= 0;
    expect(shouldTrigger).toBe(true);

    // EXPLOIT: Negative duration triggers expiry effects immediately
    // Spells that get stronger when expiring become instant-win
  });

  it('EXPLOIT: Permanent duration via integer overflow', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    const permanentSpell: ComposedSpell = {
      id: 'permanent',
      name: 'Permanent',
      technique: 'create',
      form: 'matter',
      source: 'arcane',
      manaCost: 50,
      castTime: 30,
      range: 5,
      duration: Number.MAX_SAFE_INTEGER,
      effectId: 'permanent_effect',
    };

    // Duration in ticks: 9,007,199,254,740,991
    // At 60 ticks/second: 150,119,987,579,016 seconds
    // = 4,757,859 years

    expect(permanentSpell.duration).toBe(Number.MAX_SAFE_INTEGER);

    // EXPLOIT: Use MAX_SAFE_INTEGER duration for effectively permanent effects
    // Pay once, have forever!
  });
});

describe('Timing Exploits - Prayer and Faith', () => {
  it('EXPLOIT: Spam prayers to inflate answered prayer rate', () => {
    let spiritual = createSpiritualComponent(0.5);

    // Record 100 prayers rapidly
    for (let i = 0; i < 100; i++) {
      spiritual = recordPrayer(spiritual, {
        id: `prayer_${i}`,
        type: 'plea',
        urgency: 'earnest',
        timestamp: i,
        content: 'Please help',
        answered: false,
      }, 100); // maxHistory=100 to keep all prayers
    }

    expect(spiritual.prayers.length).toBe(100);

    // Answer first 10 prayers
    for (let i = 0; i < 10; i++) {
      spiritual.prayers[i].answered = true;
      spiritual.prayers[i].responseTime = i + 1;
    }

    // Answer rate: 10/100 = 10%
    const answeredCount = spiritual.prayers.filter(p => p.answered).length;
    const answerRate = answeredCount / spiritual.prayers.length;
    expect(answerRate).toBe(0.1);

    // Now delete unanswered prayers
    spiritual.prayers = spiritual.prayers.filter(p => p.answered);

    // New answer rate: 10/10 = 100%!
    const newRate = spiritual.prayers.filter(p => p.answered).length / spiritual.prayers.length;
    expect(newRate).toBe(1.0);

    // EXPLOIT: Selectively forget unanswered prayers to boost answer rate
  });

  it('EXPLOIT: Backdated prayers for instant faith boost', () => {
    let spiritual = createSpiritualComponent(0.5);

    const currentTime = 1000;

    // Record prayer with past timestamp
    spiritual = recordPrayer(spiritual, {
      id: 'backdated',
      type: 'plea',
      urgency: 'desperate',
      timestamp: 0, // Far in the past
      content: 'Ancient prayer',
      answered: true,
      responseTime: 1, // Answered almost immediately!
    });

    // Prayer was "answered" in 1 tick
    const responseTime = 1;
    expect(responseTime).toBe(1);

    // But actual time is 1000
    expect(currentTime).toBe(1000);

    // EXPLOIT: Backdate prayers to fake instant divine response
    // Boosts faith metrics artificially
  });

  it('EXPLOIT: Multiple visions in single tick for mass conviction', () => {
    const spiritual = createSpiritualComponent(0); // Start with 0 faith

    // Receive 10 visions in same tick
    for (let i = 0; i < 10; i++) {
      spiritual.visions.push({
        id: `vision_${i}`,
        timestamp: 100, // All at same time!
        content: 'Divine revelation',
        source: 'direct',
        clarity: 1.0,
        interpreted: false,
        sharedWith: [],
      });
    }

    // Total faith impact: 0.1 * 10 = 1.0 (simulated)
    const faithImpactPerVision = 0.1;
    const totalImpact = spiritual.visions.length * faithImpactPerVision;
    expect(totalImpact).toBeCloseTo(1.0, 10);

    // Faith jumps from 0 to 1.0 instantly!
    spiritual.faith += totalImpact;
    expect(spiritual.faith).toBe(1.0);

    // EXPLOIT: Stack visions in single tick for instant max faith
  });

  it('EXPLOIT: Negative timestamp doubts for permanent faith drain', () => {
    const spiritual = createSpiritualComponent(0.5);
    spiritual.faith = 0.8;

    // Add doubt with negative timestamp
    const doubt = {
      id: 'ancient_doubt',
      timestamp: -1000,
      reason: 'Ancient question',
      severity: 0.5,
      resolved: false,
    };

    spiritual.doubts.push(doubt);

    // If doubt resolution checks (currentTime - timestamp)...
    const currentTime = 1000;
    const doubtAge = currentTime - doubt.timestamp;
    expect(doubtAge).toBe(2000); // Very old!

    // Old unresolved doubts might have huge faith penalty
    // doubtAge = 2000, so 2000 * 0.0001 = 0.2
    const penalty = Math.min(0.5, doubtAge * 0.0001); // Caps at 0.5
    expect(penalty).toBe(0.2);

    spiritual.faith -= penalty;
    expect(spiritual.faith).toBeCloseTo(0.6, 10);

    // EXPLOIT: Negative timestamp creates "ancient" doubts with max penalty
  });
});

describe('Timing Exploits - Queue Manipulation', () => {
  it('EXPLOIT: Cancel and requeue to skip to front', () => {
    const caster = createMagicUserComponent('arcane', 300, 'academic');

    // Spell queue: [A, B, C, D, E]
    const queue = ['A', 'B', 'C', 'D', 'E'];

    // Want to cast E immediately
    // Cancel all spells
    queue.length = 0;

    // Requeue only E
    queue.push('E');

    expect(queue[0]).toBe('E');

    // EXPLOIT: Clear queue to prioritize desired spell
    // Bypass queue order system
  });

  it('EXPLOIT: Insert spell during cast to skip costs', () => {
    const caster = createMagicUserComponent('arcane', 100, 'academic');

    const spell1: ComposedSpell = {
      id: 'spell1',
      name: 'Spell 1',
      technique: 'create',
      form: 'fire',
      source: 'arcane',
      manaCost: 50,
      castTime: 20,
      range: 10,
      duration: 0,
      effectId: 'damage',
    };

    // Start casting spell1
    caster.casting = true;
    caster.activeSpellId = spell1.id;

    // Mana deducted: 100 - 50 = 50
    const pool = caster.manaPools.find(p => p.source === 'arcane');
    if (pool) {
      pool.current -= spell1.manaCost;
      expect(pool.current).toBe(50);
    }

    // Mid-cast, change activeSpellId to different spell
    const spell2: ComposedSpell = {
      id: 'spell2',
      name: 'Spell 2',
      technique: 'create',
      form: 'ice',
      source: 'arcane',
      manaCost: 80, // More expensive!
      castTime: 20,
      range: 10,
      duration: 0,
      effectId: 'freeze',
    };

    caster.activeSpellId = spell2.id;

    // If mana cost is only checked at start...
    // Paid 50 mana, but get 80 mana spell!

    // EXPLOIT: Switch spell mid-cast to pay lower cost for expensive spell
  });

  it('EXPLOIT: Tick-perfect timing to double-cast', () => {
    const caster = createMagicUserComponent('arcane', 200, 'academic');

    const fastSpell: ComposedSpell = {
      id: 'fast',
      name: 'Fast',
      technique: 'create',
      form: 'fire',
      source: 'arcane',
      manaCost: 30,
      castTime: 1, // Single tick!
      range: 10,
      duration: 0,
      effectId: 'damage',
    };

    // Cast on tick 100
    let currentTick = 100;
    const startTick = currentTick;

    // Cast completes on tick 100 (instant)
    const completeTick = startTick + fastSpell.castTime;
    expect(completeTick).toBe(101);

    // If systems update in specific order:
    // 1. Start cast (tick 100)
    // 2. Update tick to 101
    // 3. Check cast completion (tick 101 >= 101, done!)
    // 4. Can cast again on same tick 101!

    // EXPLOIT: Single-tick spells can be cast twice in one frame
    // Effective cast time: 0.5 ticks
  });
});
