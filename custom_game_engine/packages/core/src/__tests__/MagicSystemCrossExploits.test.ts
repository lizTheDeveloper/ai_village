/**
 * Magic System Cross-System Exploitation Tests
 *
 * Tests for exploits across system boundaries:
 * - Magic + Economy (price manipulation, infinite wealth)
 * - Magic + Trading (quality duplication, value exploits)
 * - Magic + Crafting (free upgrades, quality multiplication)
 * - Magic + Social (reputation hacking, belief manipulation)
 * - Magic + Time (temporal exploits, cooldown skipping)
 * - Magic + Combat (invulnerability, one-shot exploits)
 */

import { describe, it, expect, beforeEach } from 'vitest';
import {
  createMagicComponent,
  createMagicUserComponent,
  getMana,
  canCastSpell,
  type MagicComponent,
  type ComposedSpell,
} from '../components/MagicComponent';
import {
  createSpiritualComponent,
  type SpiritualComponent,
} from '../components/SpiritualComponent';
import { createInventoryComponent } from '../components/InventoryComponent';
import { createAgentComponent } from '../components/AgentComponent';
import type { ItemQuality } from '../items/ItemQuality';
import { COMMERCE_PARADIGM, CRAFT_PARADIGM, LUCK_PARADIGM, BELIEF_PARADIGM } from '../magic/CreativeParadigms';

describe('Cross-Exploit - Magic + Economy', () => {
  it('EXPLOIT: Commerce magic can manipulate prices to negative', () => {
    const merchant = createMagicUserComponent('favor', 100, 'commerce');

    // Commerce magic spell: Reduce Price
    const reducePriceSpell: ComposedSpell = {
      id: 'reduce_price',
      name: 'Bargain',
      technique: 'transform',
      form: 'abstract',
      source: 'favor',
      manaCost: 10,
      castTime: 5,
      range: 10,
      duration: 100,
      effectId: 'price_multiply_0.5',
    };

    merchant.knownSpells.push({
      spellId: reducePriceSpell.id,
      proficiency: 100,
      timesCast: 0,
    });

    // Cast spell multiple times on same item
    let itemPrice = 100;
    for (let i = 0; i < 10; i++) {
      itemPrice *= 0.5; // Each cast halves price
    }

    // After 10 casts: 100 * (0.5^10) = 0.09765625
    expect(itemPrice).toBeLessThan(1);

    // Cast 20 more times
    for (let i = 0; i < 20; i++) {
      itemPrice *= 0.5;
    }

    // Price becomes effectively zero
    expect(itemPrice).toBeLessThan(0.001);

    // EXPLOIT: Can reduce any price to near-zero
    // Then buy everything for free!
  });

  it('EXPLOIT: Commerce magic price increase for infinite wealth', () => {
    const merchant = createMagicUserComponent('favor', 100, 'commerce');

    // Commerce magic spell: Increase Price
    const increasePriceSpell: ComposedSpell = {
      id: 'inflate_price',
      name: 'Prestige',
      technique: 'enhance',
      form: 'abstract',
      source: 'favor',
      manaCost: 10,
      castTime: 5,
      range: 10,
      duration: 100,
      effectId: 'price_multiply_2.0',
    };

    // Own a cheap item worth 1 gold
    let itemValue = 1;

    // Cast price increase 30 times
    for (let i = 0; i < 30; i++) {
      itemValue *= 2.0;
    }

    // 1 * (2^30) = 1,073,741,824 gold
    expect(itemValue).toBeGreaterThan(1_000_000_000);

    // EXPLOIT: Turn 1 gold into 1 billion gold
    // Then sell it for infinite wealth!
  });

  it('EXPLOIT: Luck magic to manipulate trade outcomes', () => {
    const gambler = createMagicUserComponent('karma', 100, 'luck');

    // Set luck to maximum
    gambler.knownParadigmIds.push('luck');
    const luckState = {
      currentLuck: 1000, // Way above normal
      luckDebt: 0,
      majorEvents: [],
    };

    // Use luck in trading
    // If trade success depends on random roll...
    const roll = Math.random(); // 0-1
    const luckBonus = luckState.currentLuck * 0.01; // +10.0 bonus!

    const effectiveRoll = roll + luckBonus;
    expect(effectiveRoll).toBeGreaterThan(1); // Always succeeds!

    // EXPLOIT: Infinite luck = always win trades
    // Accumulate luck debt but never pay it back
  });

  it('EXPLOIT: Belief magic to create fake demand', () => {
    const manipulator = createMagicUserComponent('faith', 100, 'belief');

    // Belief magic: Make people believe item is valuable
    const createBeliefSpell: ComposedSpell = {
      id: 'create_belief',
      name: 'Mass Delusion',
      technique: 'create',
      form: 'mind',
      source: 'faith',
      manaCost: 50,
      castTime: 100,
      range: 100,
      duration: 1000,
      effectId: 'belief_in_value',
    };

    // Cast on worthless item
    const worthlessRock = {
      id: 'rock',
      name: 'Rock',
      baseValue: 0,
    };

    // Track believers
    const believers = 1000; // Affected NPCs
    const beliefStrength = 0.8; // 80% conviction

    // Price influenced by belief
    const perceivedValue = worthlessRock.baseValue + (believers * beliefStrength * 10);
    expect(perceivedValue).toBe(8000);

    // EXPLOIT: Worthless item now worth 8000 gold
    // Sell before belief wears off!
  });
});

describe('Cross-Exploit - Magic + Trading', () => {
  it('EXPLOIT: Craft magic to upgrade items before selling', () => {
    const crafter = createMagicUserComponent('will', 100, 'craft');
    const inventory = createInventoryComponent(20);

    // Create low quality item
    const item = {
      itemId: 'sword',
      quantity: 1,
      quality: 0.5, // poor quality
    };

    inventory.slots[0] = item;

    // Craft magic: Upgrade Quality
    const upgradeSpell: ComposedSpell = {
      id: 'masterwork',
      name: 'Masterwork',
      technique: 'enhance',
      form: 'matter',
      source: 'will',
      manaCost: 20,
      castTime: 10,
      range: 1,
      duration: 0,
      effectId: 'quality_upgrade',
    };

    // Cast spell 5 times
    let currentQuality: ItemQuality = 'poor'; // 0.5x value
    currentQuality = 'normal'; // 1.0x
    currentQuality = 'fine'; // 1.5x
    currentQuality = 'masterwork'; // 2.0x
    currentQuality = 'legendary'; // 5.0x

    const basePrice = 100;
    const poorPrice = basePrice * 0.5; // 50 gold
    const legendaryPrice = basePrice * 5.0; // 500 gold

    expect(legendaryPrice).toBe(poorPrice * 10);

    // EXPLOIT: 20 mana per cast, 100 mana total
    // Turn 50 gold item into 500 gold item
    // Profit: 450 gold from 100 mana!
  });

  it('EXPLOIT: Quality duplication via paradigm switching', () => {
    const dualCaster = createMagicUserComponent('will', 100, 'craft');

    // Know both Craft and Sympathy paradigms
    dualCaster.knownParadigmIds = ['craft', 'sympathy'];

    // Create masterwork item
    const original = {
      itemId: 'sword_master',
      quality: 'legendary',
      value: 1000,
    };

    // Use Sympathy to create link to cheaper item
    const cheap = {
      itemId: 'sword_poor',
      quality: 'poor',
      value: 50,
    };

    // Sympathy: Create Link spell
    const linkSpell: ComposedSpell = {
      id: 'sympathetic_link',
      name: 'Binding',
      technique: 'connect',
      form: 'matter',
      source: 'will',
      manaCost: 30,
      castTime: 50,
      range: 0,
      duration: -1, // Permanent!
      effectId: 'sympathy_link',
    };

    // Now enhance cheap item via link
    // Enhancement transfers through link to original!
    cheap.quality = 'legendary'; // Free upgrade!

    // EXPLOIT: Upgrade cheap item, affects expensive item via sympathy
    // Duplicate legendary items for free!
  });

  it('EXPLOIT: Time dilation to skip trade cooldowns', () => {
    const timeMage = createMagicUserComponent('arcane', 100, 'academic');

    // Time magic: Accelerate Time
    const timeSpell: ComposedSpell = {
      id: 'accelerate',
      name: 'Haste',
      technique: 'transform',
      form: 'abstract',
      source: 'arcane',
      manaCost: 50,
      castTime: 10,
      range: 0,
      duration: 100,
      effectId: 'time_multiply_10',
    };

    // Trading system has cooldown: 1 trade per day (1440 ticks)
    const tradeCooldown = 1440;
    let currentTick = 0;

    // Cast time acceleration
    const timeMultiplier = 10; // Time passes 10x faster for caster

    // Wait 144 ticks
    currentTick += 144;

    // From caster's perspective: 144 * 10 = 1440 ticks passed
    const perceivedTime = currentTick * timeMultiplier;
    expect(perceivedTime).toBe(tradeCooldown);

    // EXPLOIT: Skip cooldowns by accelerating personal time
    // Make 10 trades while others make 1!
  });
});

describe('Cross-Exploit - Magic + Crafting', () => {
  it('EXPLOIT: Craft magic to create items from nothing', () => {
    const creator = createMagicUserComponent('will', 100, 'craft');
    const inventory = createInventoryComponent(20);

    // Craft magic: Create Matter
    const createSpell: ComposedSpell = {
      id: 'create_matter',
      name: 'Conjure',
      technique: 'create',
      form: 'matter',
      source: 'will',
      manaCost: 50,
      castTime: 100,
      range: 1,
      duration: -1, // Permanent!
      effectId: 'create_iron_ore',
    };

    // Check if creation is permanent
    if (createSpell.duration === -1) {
      // Create expensive material from nothing
      const ironOre = {
        itemId: 'iron_ore',
        quantity: 10,
      };

      inventory.slots[0] = ironOre;

      // EXPLOIT: 50 mana = 500 gold of materials
      // Infinite wealth from mana!
      const filledSlots = inventory.slots.filter(s => s.itemId !== null);
      expect(filledSlots.length).toBe(1);
    }
  });

  it('EXPLOIT: Conservation law violation via paradigm mixing', () => {
    const mixedMage = createMagicUserComponent('arcane', 100, 'academic');

    // Academic magic follows Conservation law
    // But what if we use Blood magic (no conservation)?
    mixedMage.knownParadigmIds = ['academic', 'blood_magic'];
    mixedMage.primarySource = 'blood';

    // Academic spell: Create matter (should require equivalent exchange)
    const academicCreate: ComposedSpell = {
      id: 'transmute',
      name: 'Transmute',
      technique: 'transform',
      form: 'matter',
      source: 'arcane',
      manaCost: 30,
      castTime: 50,
      range: 1,
      duration: 0,
      effectId: 'lead_to_gold',
    };

    // Switch to blood magic paradigm to bypass conservation
    mixedMage.homeParadigmId = 'blood_magic';

    // Cast academic spell using blood magic rules
    // Conservation law might not apply!

    const leadValue = 10;
    const goldValue = 1000;

    // EXPLOIT: Transform 10 gold of lead into 1000 gold
    // Bypassing conservation law via paradigm switching!
    expect(goldValue).toBe(leadValue * 100);
  });

  it('EXPLOIT: Recursive crafting quality multiplication', () => {
    const crafter = createMagicUserComponent('will', 200, 'craft');

    let quality = 'normal'; // 1.0x multiplier
    const baseValue = 100;

    // Craft spell: Enhance Quality
    const enhanceSpell: ComposedSpell = {
      id: 'enhance',
      name: 'Enhance',
      technique: 'enhance',
      form: 'matter',
      source: 'will',
      manaCost: 10,
      castTime: 5,
      range: 1,
      duration: 0,
      effectId: 'quality_plus_one',
    };

    // What if we enhance an item that's already being crafted?
    // Quality bonus might stack multiplicatively!

    let value = baseValue;

    // Enhance 5 times during crafting
    for (let i = 0; i < 5; i++) {
      value *= 1.5; // Each enhance = +50% quality
    }

    // 100 * (1.5^5) = 759.375
    expect(value).toBeGreaterThan(750);

    // Then finish crafting with quality bonus
    value *= 2.0; // Legendary quality

    // Final: 1518.75 gold
    expect(value).toBeGreaterThan(1500);

    // EXPLOIT: Stack quality bonuses during crafting
    // Turn 100 gold materials into 1500 gold item!
  });
});

describe('Cross-Exploit - Magic + Social', () => {
  it('EXPLOIT: Belief magic to create instant religion', () => {
    const prophet = createMagicUserComponent('faith', 100, 'belief');
    const spiritual = createSpiritualComponent(0.5);

    // Belief magic: Create Belief
    const createBeliefSpell: ComposedSpell = {
      id: 'revelation',
      name: 'Divine Revelation',
      technique: 'create',
      form: 'mind',
      source: 'faith',
      manaCost: 100,
      castTime: 10,
      range: 100,
      duration: -1, // Permanent!
      effectId: 'create_belief_in_deity',
    };

    // Cast on large crowd
    const affectedNPCs = 1000;
    const beliefStrength = 0.9; // Strong conviction

    // Each believer generates divine favor
    const favorPerBeliever = 1;
    const totalFavor = affectedNPCs * beliefStrength * favorPerBeliever;

    expect(totalFavor).toBe(900);

    // EXPLOIT: 100 mana creates 900 divine favor
    // Use favor to cast more powerful spells
    // Create self-reinforcing belief loop!
  });

  it('EXPLOIT: Song magic for mass mind control', () => {
    const bard = createMagicUserComponent('will', 100, 'song');

    // Song magic: Charm
    const charmSong: ComposedSpell = {
      id: 'sirens_call',
      name: "Siren's Call",
      technique: 'control',
      form: 'mind',
      source: 'will',
      manaCost: 50,
      castTime: 20,
      range: 50, // Large area
      duration: 200,
      effectId: 'charm_all',
    };

    // Song affects all in range
    const npcsInRange = 100;

    // While charmed, NPCs give items/gold
    const goldPerNPC = 10;
    const totalGold = npcsInRange * goldPerNPC;

    expect(totalGold).toBe(1000);

    // EXPLOIT: 50 mana = 1000 gold
    // Plus mass control for 200 ticks
    // Can make NPCs fight for you, give items, etc.
  });

  it('EXPLOIT: Debt magic to enslave NPCs', () => {
    const faeDealer = createMagicUserComponent('favor', 100, 'debt');

    // Debt magic: Grant Wish (creates debt)
    const wishSpell: ComposedSpell = {
      id: 'fae_bargain',
      name: 'Bargain',
      technique: 'create',
      form: 'abstract',
      source: 'favor',
      manaCost: 10,
      castTime: 5,
      range: 10,
      duration: -1, // Debt is permanent!
      effectId: 'create_debt',
    };

    // Grant small wish: 100 gold
    const wishValue = 100;

    // But debt compounds!
    let debt = wishValue;
    const interestRate = 1.1; // 10% per day

    // After 30 days
    for (let i = 0; i < 30; i++) {
      debt *= interestRate;
    }

    // 100 * (1.1^30) = 1,744.94
    expect(debt).toBeGreaterThan(1700);

    // NPC can never pay back debt
    // Becomes permanent servant!

    // EXPLOIT: Small debts become infinite debt
    // Enslave NPCs with compounding interest
  });

  it('EXPLOIT: Bureaucratic magic to rewrite laws', () => {
    const bureaucrat = createMagicUserComponent('favor', 100, 'bureaucratic');

    // Bureaucratic magic: Amend Law
    const amendSpell: ComposedSpell = {
      id: 'amendment',
      name: 'Legislative Amendment',
      technique: 'transform',
      form: 'abstract',
      source: 'favor',
      manaCost: 80,
      castTime: 100,
      range: 0,
      duration: -1, // Permanent law change!
      effectId: 'change_law',
    };

    // Current law: "Theft is illegal"
    const currentLaw = 'theft_illegal';

    // Cast spell to change law
    const newLaw = 'theft_legal_for_caster';

    // EXPLOIT: Make yourself exempt from laws
    // Or make crimes legal for you
    // Or declare yourself owner of all property
    expect(newLaw).not.toBe(currentLaw);
  });
});

describe('Cross-Exploit - Magic + Time', () => {
  it('EXPLOIT: Age magic to skip progression', () => {
    const timeMage = createMagicUserComponent('life', 100, 'age');
    const agent = createAgentComponent('TimeMage', { x: 0, y: 0 });

    // Age magic: Accelerate Growth
    const ageSpell: ComposedSpell = {
      id: 'rapid_growth',
      name: 'Mature',
      technique: 'transform',
      form: 'body',
      source: 'life',
      manaCost: 50,
      castTime: 10,
      range: 0,
      duration: 0,
      effectId: 'age_plus_years',
    };

    // Age yourself by 10 years instantly
    let experienceGained = 0;

    // Normally: 1 year = 10,000 experience
    const yearsSkipped = 10;
    experienceGained = yearsSkipped * 10000;

    expect(experienceGained).toBe(100000);

    // EXPLOIT: Skip 10 years of grinding
    // Gain 100,000 experience instantly
    // But still young physically? Or aged?
  });

  it('EXPLOIT: Seasonal magic to create permanent summer', () => {
    const seasonMage = createMagicUserComponent('nature', 100, 'seasonal');

    // Seasonal magic: Lock Season
    const lockSpell: ComposedSpell = {
      id: 'eternal_summer',
      name: 'Eternal Summer',
      technique: 'create',
      form: 'abstract',
      source: 'nature',
      manaCost: 100,
      castTime: 100,
      range: 1000, // Huge area
      duration: -1, // Permanent!
      effectId: 'lock_season_summer',
    };

    // Summer bonuses:
    const cropGrowthRate = 2.0; // Double speed
    const comfortBonus = 0.2; // +20% happiness
    const noWinterStarvation = true;

    expect(cropGrowthRate).toBe(2.0);

    // EXPLOIT: Permanent summer = double food production
    // No winter deaths, permanent happiness bonus
    // Break seasonal balance!
  });

  it('EXPLOIT: Lunar magic to manipulate night/day cycle', () => {
    const lunarMage = createMagicUserComponent('lunar', 100, 'lunar');

    // Lunar magic: Extend Night
    const extendNightSpell: ComposedSpell = {
      id: 'endless_night',
      name: 'Eclipse',
      technique: 'transform',
      form: 'abstract',
      source: 'lunar',
      manaCost: 80,
      castTime: 50,
      range: 500,
      duration: 1000, // Very long
      effectId: 'night_only',
    };

    // Night bonuses for lunar mage:
    const powerMultiplier = 3.0; // Triple power at night
    const stealthBonus = 0.5; // +50% stealth

    // During day, cast endless night
    expect(powerMultiplier).toBe(3.0);

    // EXPLOIT: Always have night bonuses
    // Other NPCs suffer day/night penalties
    // Permanent advantage!
  });

  it('EXPLOIT: Paradox magic to reverse death', () => {
    const paradoxMage = createMagicUserComponent('void', 200, 'paradox');

    // Paradox magic: Temporal Reversal
    const reverseSpell: ComposedSpell = {
      id: 'undo_death',
      name: 'Paradox',
      technique: 'transform',
      form: 'abstract',
      source: 'void',
      manaCost: 200,
      castTime: 1,
      range: 0,
      duration: 0,
      effectId: 'reverse_time',
    };

    // Die in combat
    let isDead = true;
    let health = 0;

    // Cast spell post-death (if possible)
    // Reverse to state before death
    if (paradoxMage.manaPools[0].current >= 200) {
      isDead = false;
      health = 100;
    }

    expect(health).toBe(100);

    // EXPLOIT: Can't die if you can reverse death
    // Immortality via paradox magic!
  });
});

describe('Cross-Exploit - Magic + Combat', () => {
  it('EXPLOIT: Silence magic for guaranteed critical hits', () => {
    const silentMage = createMagicUserComponent('void', 100, 'silence');

    // Silence magic: Zone of Silence
    const silenceSpell: ComposedSpell = {
      id: 'deafening_silence',
      name: 'Absolute Silence',
      technique: 'create',
      form: 'abstract',
      source: 'void',
      manaCost: 30,
      castTime: 5,
      range: 20,
      duration: 100,
      effectId: 'silence_zone',
    };

    // In silence, opponents can't hear attacks coming
    const surpriseBonus = 2.0; // Double damage
    const cannotCallForHelp = true;
    const spellCastingDisabled = true; // Verbal components fail!

    expect(surpriseBonus).toBe(2.0);
    expect(spellCastingDisabled).toBe(true);

    // EXPLOIT: Silence disables all verbal magic
    // Most mages use verbal components
    // Instant win vs other casters!
  });

  it('EXPLOIT: Dream magic for risk-free combat', () => {
    const dreamMage = createMagicUserComponent('mind', 100, 'dream');

    // Dream magic: Pull Into Dream
    const dreamSpell: ComposedSpell = {
      id: 'dream_realm',
      name: 'Dreamscape',
      technique: 'create',
      form: 'mind',
      source: 'mind',
      manaCost: 100,
      castTime: 20,
      range: 10,
      duration: 500,
      effectId: 'dream_world',
    };

    // In dream realm:
    const deathIsFake = true; // Dying just wakes you up
    const casterHasFullControl = true; // Your dream, your rules
    const opponentTrapped = true;

    expect(deathIsFake).toBe(true);

    // EXPLOIT: Fight in dreams where you can't die
    // Full control over dream physics
    // Opponent trapped until duration ends or you wake them
  });

  it('EXPLOIT: Consumption magic for vampire-style power drain', () => {
    const consumer = createMagicUserComponent('life', 100, 'consumption');

    // Consumption magic: Drain Life
    const drainSpell: ComposedSpell = {
      id: 'life_drain',
      name: 'Consume',
      technique: 'destroy',
      form: 'body',
      source: 'life',
      manaCost: 20,
      castTime: 10,
      range: 5,
      duration: 0,
      effectId: 'drain_health',
    };

    let casterHealth = 50;
    let targetHealth = 100;

    // Drain 50 health from target
    const drainAmount = 50;
    targetHealth -= drainAmount;
    casterHealth += drainAmount; // Healing!

    expect(casterHealth).toBe(100);
    expect(targetHealth).toBe(50);

    // EXPLOIT: Each attack heals you
    // Can't die in prolonged combat
    // The more you fight, the stronger you get!
  });

  it('EXPLOIT: Echo magic for infinite combo chains', () => {
    const echoMage = createMagicUserComponent('arcane', 100, 'echo');

    // Echo magic: Repeat Action
    const echoSpell: ComposedSpell = {
      id: 'echo_strike',
      name: 'Echo',
      technique: 'create',
      form: 'abstract',
      source: 'arcane',
      manaCost: 30,
      castTime: 5,
      range: 10,
      duration: 50,
      effectId: 'echo_last_action',
    };

    // Attack deals 100 damage
    const baseDamage = 100;

    // Cast Echo
    // Your attack echoes 5 times
    const echoCount = 5;
    const totalDamage = baseDamage * (1 + echoCount);

    expect(totalDamage).toBe(600);

    // But what if you Echo the Echo spell?
    // Infinite recursion!
    const echoEchoCount = echoCount * echoCount;
    expect(echoEchoCount).toBe(25);

    // EXPLOIT: Echo your echoes for exponential damage
    // One attack becomes hundreds!
  });

  it('EXPLOIT: Threshold magic for invulnerable sanctuaries', () => {
    const wardMage = createMagicUserComponent('arcane', 100, 'threshold');

    // Threshold magic: Create Barrier
    const barrierSpell: ComposedSpell = {
      id: 'sanctuary',
      name: 'Sanctum',
      technique: 'create',
      form: 'abstract',
      source: 'arcane',
      manaCost: 100,
      castTime: 50,
      range: 0,
      duration: -1, // Permanent!
      effectId: 'threshold_barrier',
    };

    // Barrier prevents:
    const canBlockPhysical = true;
    const canBlockMagic = true;
    const canBlockProjectiles = true;
    const oneWay = true; // Can attack out, can't be attacked in!

    expect(oneWay).toBe(true);

    // EXPLOIT: Create permanent one-way barrier
    // Safe inside, can attack outside
    // Invulnerable archer tower!
  });
});

describe('Cross-Exploit - Combo Exploits', () => {
  it('MEGA EXPLOIT: Debt + Commerce + Belief combo', () => {
    const mastermind = createMagicUserComponent('favor', 300, 'debt');
    mastermind.knownParadigmIds = ['debt', 'commerce', 'belief'];

    // Step 1: Use Belief magic to convince NPC item is valuable
    const believedValue = 10000;

    // Step 2: Offer to "buy" it on credit using Debt magic
    const debt = believedValue;

    // Step 3: Use Commerce magic to crash market value
    const actualValue = 1;

    // Step 4: Pay back debt at crashed price
    const profit = debt - actualValue;

    expect(profit).toBe(9999);

    // EXPLOIT: Create fake value, buy on credit, crash value, profit!
  });

  it('MEGA EXPLOIT: Age + Seasonal + Lunar time manipulation', () => {
    const chronoMage = createMagicUserComponent('nature', 300, 'seasonal');
    chronoMage.knownParadigmIds = ['seasonal', 'lunar', 'age'];

    // Step 1: Lock season to Summer (double crop growth)
    const cropMultiplier = 2.0;

    // Step 2: Extend night (lunar power bonus)
    const powerBonus = 3.0;

    // Step 3: Age crops rapidly
    const timeAcceleration = 10;

    // Total: 2.0 * 3.0 * 10 = 60x production
    const totalMultiplier = cropMultiplier * powerBonus * timeAcceleration;
    expect(totalMultiplier).toBe(60);

    // EXPLOIT: 60x food production!
    // Feed entire kingdom with one field!
  });

  it('MEGA EXPLOIT: Sympathy + Craft + Echo duplication', () => {
    const duplicator = createMagicUserComponent('will', 300, 'sympathy');
    duplicator.knownParadigmIds = ['sympathy', 'craft', 'echo'];

    // Step 1: Create sympathetic link between cheap and expensive item
    const cheap = { value: 1 };
    const expensive = { value: 1000 };

    // Step 2: Use Craft magic to enhance cheap item
    cheap.value = 1000;

    // Step 3: Link transfers enhancement to expensive item
    expensive.value = 2000; // Both are now 1000!

    // Step 4: Echo the enhancement
    // Enhancement happens 5 more times
    const finalValue = expensive.value * 5;
    expect(finalValue).toBe(10000);

    // EXPLOIT: Turn 1 gold into 10,000 gold!
  });

  it('MEGA EXPLOIT: Dream + Paradox + Consumption infinite power', () => {
    const godMage = createMagicUserComponent('void', 500, 'paradox');
    godMage.knownParadigmIds = ['paradox', 'dream', 'consumption'];

    // Step 1: Enter dream realm (can't die)
    const inDream = true;

    // Step 2: Use Consumption to drain power
    let power = 0;
    const drainPerSecond = 100;

    // Step 3: When about to die from backlash, use Paradox to reverse
    power += drainPerSecond * 100; // 100 seconds of drain
    expect(power).toBe(10000);

    // Backlash would kill you, but:
    // - In dream so death is fake
    // - Paradox reverses the damage
    // - Keep the power!

    // EXPLOIT: Infinite power with no consequences!
  });

  it('MEGA EXPLOIT: Silence + Bureaucratic + Threshold lockdown', () => {
    const tyrant = createMagicUserComponent('void', 400, 'bureaucratic');
    tyrant.knownParadigmIds = ['bureaucratic', 'silence', 'threshold'];

    // Step 1: Use Bureaucratic magic to make yourself ruler
    const isRuler = true;

    // Step 2: Create Threshold barriers around city
    const citySealed = true;

    // Step 3: Cast Silence over entire city
    const noVoice = true;

    // Result:
    // - You are legal ruler (bureaucratic)
    // - No one can leave (threshold)
    // - No one can speak against you (silence)
    // - Can't cast verbal spells to resist

    expect(isRuler && citySealed && noVoice).toBe(true);

    // EXPLOIT: Instant dictatorship with magical enforcement!
  });
});
