/**
 * Test script for riddle generation and solving
 *
 * This script tests whether LLMs can:
 * 1. Generate valid riddles with answers
 * 2. Solve the riddles they generate
 * 3. Solve riddles generated by other LLMs
 *
 * Usage:
 *   npm run tsx scripts/test-riddle-generation.ts
 */

import { OpenAICompatProvider } from '../packages/llm/src/OpenAICompatProvider.js';
import { RiddleGenerator, type HeroContext } from '../packages/core/src/divinity/RiddleGenerator.js';
import * as dotenv from 'dotenv';

// Load environment variables
dotenv.config();

// Configuration
const MODEL = process.env.GROQ_MODEL || 'llama-3.3-70b-versatile';
const GROQ_API_KEY = process.env.GROQ_API_KEY || '';
const TRIALS_PER_DIFFICULTY = 5;

if (!GROQ_API_KEY) {
  console.error('ERROR: GROQ_API_KEY not found in .env file');
  process.exit(1);
}

interface TestResults {
  difficulty: 'easy' | 'medium' | 'hard';
  generated: number;
  solved: number;
  failed: number;
  errors: number;
  riddles: Array<{
    question: string;
    answer: string;
    solved: boolean;
    llmAnswer?: string;
  }>;
}

async function main() {
  console.log('='.repeat(80));
  console.log('RIDDLE GENERATION AND SOLVING TEST');
  console.log('='.repeat(80));
  console.log(`Provider: Groq`);
  console.log(`Model: ${MODEL}`);
  console.log(`Trials per difficulty: ${TRIALS_PER_DIFFICULTY}\n`);

  // Initialize Groq LLM provider
  const llm = new OpenAICompatProvider(
    MODEL,
    'https://api.groq.com/openai/v1',
    GROQ_API_KEY
  );

  const generator = new RiddleGenerator(llm);

  // Test classic riddles at each difficulty
  const difficulties: Array<'easy' | 'medium' | 'hard'> = ['easy', 'medium', 'hard'];
  const allResults: TestResults[] = [];

  for (const difficulty of difficulties) {
    console.log(`\n${'='.repeat(80)}`);
    console.log(`Testing ${difficulty.toUpperCase()} riddles`);
    console.log('='.repeat(80));

    const results: TestResults = {
      difficulty,
      generated: 0,
      solved: 0,
      failed: 0,
      errors: 0,
      riddles: [],
    };

    for (let i = 0; i < TRIALS_PER_DIFFICULTY; i++) {
      console.log(`\nTrial ${i + 1}/${TRIALS_PER_DIFFICULTY}:`);
      console.log('-'.repeat(80));

      try {
        // Generate riddle
        console.log('Generating riddle...');
        const riddle = await generator.generateClassicRiddle(difficulty);
        results.generated++;

        // Enable judgment mode - the God of Death judges the answer
        riddle.useJudgment = true;

        console.log(`\nRiddle: "${riddle.question}"`);
        console.log(`Reference answer: "${riddle.correctAnswer}" (not shown to solver)`);
        console.log(`Judgment mode: God of Death will judge the answer`);
        if (riddle.hint) {
          console.log(`Hint: "${riddle.hint}"`);
        }

        // Test if LLM can solve it (with God of Death judging)
        console.log('\nTesting if LLM can solve (with judgment)...');
        const solveResult = await generator.testRiddle(riddle);

        if (solveResult.solved) {
          console.log(`✓ SOLVED! Answer: "${solveResult.answer}"`);
          results.solved++;
        } else {
          console.log(`✗ FAILED. LLM answered: "${solveResult.answer}"`);
          results.failed++;
        }

        results.riddles.push({
          question: riddle.question,
          answer: riddle.correctAnswer,
          solved: solveResult.solved,
          llmAnswer: solveResult.answer,
        });
      } catch (error) {
        console.error(`✗ ERROR:`, error instanceof Error ? error.message : error);
        results.errors++;
      }
    }

    allResults.push(results);

    // Summary for this difficulty
    console.log('\n' + '='.repeat(80));
    console.log(`${difficulty.toUpperCase()} Summary:`);
    console.log(`  Generated: ${results.generated}/${TRIALS_PER_DIFFICULTY}`);
    console.log(`  Solved: ${results.solved}/${results.generated} (${((results.solved / results.generated) * 100).toFixed(1)}%)`);
    console.log(`  Failed: ${results.failed}/${results.generated} (${((results.failed / results.generated) * 100).toFixed(1)}%)`);
    console.log(`  Errors: ${results.errors}`);
  }

  // Overall summary
  console.log('\n' + '='.repeat(80));
  console.log('OVERALL SUMMARY');
  console.log('='.repeat(80));

  const totalGenerated = allResults.reduce((sum, r) => sum + r.generated, 0);
  const totalSolved = allResults.reduce((sum, r) => sum + r.solved, 0);
  const totalFailed = allResults.reduce((sum, r) => sum + r.failed, 0);
  const totalErrors = allResults.reduce((sum, r) => sum + r.errors, 0);

  console.log(`\nTotal riddles generated: ${totalGenerated}`);
  console.log(`Total solved: ${totalSolved} (${((totalSolved / totalGenerated) * 100).toFixed(1)}%)`);
  console.log(`Total failed: ${totalFailed} (${((totalFailed / totalGenerated) * 100).toFixed(1)}%)`);
  console.log(`Total errors: ${totalErrors}`);

  console.log('\nSuccess rate by difficulty:');
  for (const results of allResults) {
    const rate = results.generated > 0 ? (results.solved / results.generated) * 100 : 0;
    console.log(`  ${results.difficulty}: ${results.solved}/${results.generated} (${rate.toFixed(1)}%)`);
  }

  // Test personalized riddles
  console.log('\n' + '='.repeat(80));
  console.log('PERSONALIZED RIDDLES TEST');
  console.log('='.repeat(80));

  const heroContexts: HeroContext[] = [
    {
      name: 'Aldric the Brave',
      destiny: 'unite the warring kingdoms',
      causeOfDeath: 'betrayed by trusted ally',
      notableDeeds: ['saved village from bandits', 'slayed the dragon of Mount Doom'],
    },
    {
      name: 'Lyra Moonshadow',
      destiny: 'restore the ancient magic',
      causeOfDeath: 'sacrificed herself to seal the demon',
      notableDeeds: ['mastered forbidden spells', 'discovered the lost library'],
    },
    {
      name: 'Theron Ironheart',
      destiny: 'defend the realm from darkness',
      causeOfDeath: 'fell in final battle against undead horde',
      notableDeeds: ['held the gate for three days', 'forged the legendary sword'],
    },
  ];

  let personalizedSolved = 0;
  let personalizedTotal = 0;

  for (const context of heroContexts) {
    console.log(`\nHero: ${context.name}`);
    console.log(`Destiny: ${context.destiny}`);
    console.log('-'.repeat(80));

    try {
      const riddle = await generator.generatePersonalizedRiddle(context);
      personalizedTotal++;

      // Enable judgment mode
      riddle.useJudgment = true;

      console.log(`Riddle: "${riddle.question}"`);
      console.log(`Reference answer: "${riddle.correctAnswer}" (not shown to solver)`);
      console.log(`Judgment mode: God of Death will judge the answer`);

      const solveResult = await generator.testRiddle(riddle);

      if (solveResult.solved) {
        console.log(`✓ SOLVED! Answer: "${solveResult.answer}"`);
        personalizedSolved++;
      } else {
        console.log(`✗ FAILED. LLM answered: "${solveResult.answer}"`);
      }
    } catch (error) {
      console.error(`✗ ERROR:`, error instanceof Error ? error.message : error);
    }
  }

  console.log('\n' + '='.repeat(80));
  console.log('PERSONALIZED RIDDLES Summary:');
  console.log(`  Solved: ${personalizedSolved}/${personalizedTotal} (${((personalizedSolved / personalizedTotal) * 100).toFixed(1)}%)`);

  // Recommendations
  console.log('\n' + '='.repeat(80));
  console.log('RECOMMENDATIONS');
  console.log('='.repeat(80));

  const overallSuccessRate = (totalSolved / totalGenerated) * 100;

  if (overallSuccessRate >= 80) {
    console.log('✓ Success rate is high enough for production use.');
    console.log('  The LLM can reliably generate and solve riddles.');
  } else if (overallSuccessRate >= 60) {
    console.log('⚠ Success rate is moderate. Consider:');
    console.log('  - Adding more accepted answer variations');
    console.log('  - Using semantic matching with LLM evaluation');
    console.log('  - Adjusting riddle generation prompts');
  } else {
    console.log('✗ Success rate is too low for reliable gameplay.');
    console.log('  Recommendations:');
    console.log('  - Use curated mythic riddles instead of generated ones');
    console.log('  - Try a different/larger model');
    console.log('  - Implement more robust answer matching');
  }

  console.log('\n' + '='.repeat(80));
  console.log('Test complete!');
  console.log('='.repeat(80));
}

// Run the test
main().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
});
